"use strict";function tokenize(e){const t=[];let n=0;const r=e=>/[a-zA-Z_]/.test(e),o=e=>/[0-9]/.test(e),i=e=>r(e)||o(e);for(;n<e.length;){let p=e[n];if(" "===p||"\t"===p||"\n"===p||"\r"===p){n++;continue}if("/"===p&&"/"===e[n+1]){for(;n<e.length&&"\n"!==e[n];)n++;continue}if('"'===p||"'"===p){const r=p;let o=n++,i="";for(;n<e.length&&e[n]!==r;)if("\\"===e[n]){if(n+1>=e.length)break;const t=e[n+1];i+="n"===t?"\n":"r"===t?"\r":"t"===t?"\t":"b"===t?"\b":"f"===t?"\f":"v"===t?"\v":"\\"===t?"\\":'"'===t?'"':"'"===t?"'":t,n+=2}else i+=e[n++];if(e[n]!==r)throw new Error("Unterminated string literal at "+o);n++,t.push({type:"string",value:i,pos:o});continue}if(o(p)){let r=n,i="",p=!1;for(;n<e.length&&(o(e[n])||"."===e[n]);){if("."===e[n]){if(p)break;p=!0}i+=e[n++]}p||"n"!==e[n]?t.push({type:"number",value:i,pos:r}):(n++,t.push({type:"bigint",value:i+"n",pos:r}));continue}if(r(p)){let r=n,o="";for(;n<e.length&&i(e[n]);)o+=e[n++];const p=new Set(["type","function","export","let","const","return","if","else","while","for","switch","case","default","break","try","catch","finally","class","new","async","await"]);p.add("static"),t.push({type:p.has(o)?"keyword":"identifier",value:o,pos:r});continue}const a=e.substr(n,3);if(new Set(["===","!=="]).has(a)){t.push({type:"punct",value:a,pos:n}),n+=3;continue}const u=e.substr(n,2);if(new Set(["==","!=","<=",">=","&&","||","=>","++","--"]).has(u)){t.push({type:"punct",value:u,pos:n}),n+=2;continue}if(!["{","}","(",")",";","+","-","*","/","=",",",":",".","<",">","[","]","?"].includes(p))throw new Error("Unexpected character: '"+p+"' at position "+n);t.push({type:"punct",value:p,pos:n}),n++}return t}const tokenizeTS=tokenize;function Program(e){return{kind:"Program",body:e}}function TypeDecl(e,t,n){return{kind:"TypeDecl",name:e,type:t,pos:n}}function VarDecl(e,t,n,r){return{kind:"VarDecl",name:e,type:t,init:n,pos:r}}function ConstDecl(e,t,n,r){return{kind:"ConstDecl",name:e,type:t,init:n,pos:r}}function FuncDecl(e,t,n,r,o,i=!1){return{kind:"FuncDecl",name:e,params:t,returnType:n,body:r,pos:o,isAsync:i}}function Param(e,t,n){return{kind:"Param",name:e,type:t,pos:n}}function Block(e,t){return{kind:"Block",statements:e,pos:t}}function ReturnStmt(e,t){return{kind:"ReturnStmt",expr:e,pos:t}}function ExprStmt(e,t){return{kind:"ExprStmt",expr:e,pos:t}}function ForStmt(e,t,n,r,o){return{kind:"ForStmt",init:e,test:t,update:n,body:r,pos:o}}function ForOfStmt(e,t,n,r){return{kind:"ForOfStmt",left:e,right:t,body:n,pos:r}}function ForInStmt(e,t,n,r){return{kind:"ForInStmt",left:e,right:t,body:n,pos:r}}function SwitchStmt(e,t,n){return{kind:"SwitchStmt",discriminant:e,cases:t,pos:n}}function CaseClause(e,t,n){return{kind:"CaseClause",test:e,consequent:t,pos:n}}function BreakStmt(e){return{kind:"BreakStmt",pos:e}}function TypeRef(e,t){return{kind:"TypeRef",name:e,pos:t}}function ObjectType(e,t){return{kind:"ObjectType",properties:e,pos:t}}function TypeProperty(e,t,n){return{kind:"TypeProperty",name:e,type:t,pos:n}}function ArrayType(e,t){return{kind:"ArrayType",element:e,pos:t}}function ExportDecl(e,t){return{kind:"ExportDecl",decl:e,pos:t}}function Identifier(e,t){return{kind:"Identifier",name:e,pos:t}}function NumberLiteral(e,t){return{kind:"NumberLiteral",value:e,pos:t}}function BigIntLiteral(e,t){return{kind:"BigIntLiteral",value:e,pos:t}}function StringLiteral(e,t){return{kind:"StringLiteral",value:e,pos:t}}function BoolLiteral(e,t){return{kind:"BoolLiteral",value:e,pos:t}}function BinaryExpr(e,t,n,r){return{kind:"BinaryExpr",op:e,left:t,right:n,pos:r}}function ConditionalExpr(e,t,n,r){return{kind:"ConditionalExpr",cond:e,thenExpr:t,elseExpr:n,pos:r}}function CallExpr(e,t,n){return{kind:"CallExpr",callee:e,args:t,pos:n}}function MemberExpr(e,t,n){return{kind:"MemberExpr",object:e,property:t,pos:n}}function ArrayLiteral(e,t){return{kind:"ArrayLiteral",elements:e,pos:t}}function IndexExpr(e,t,n){return{kind:"IndexExpr",object:e,index:t,pos:n}}function ArrowFunction(e,t,n,r=!1){return{kind:"ArrowFunction",params:e,body:t,pos:n,isAsync:r}}function AwaitExpr(e,t){return{kind:"AwaitExpr",argument:e,pos:t}}function UpdateExpr(e,t,n,r){return{kind:"UpdateExpr",argument:e,operator:t,prefix:n,pos:r}}function ObjectLiteral(e,t){return{kind:"ObjectLiteral",properties:e,pos:t}}function ObjectLiteralProperty(e,t,n){return{kind:"ObjectLiteralProperty",name:e,value:t,pos:n}}function FunctionExpr(e,t,n,r,o,i=!1){return{kind:"FunctionExpr",name:e,params:t,returnType:n,body:r,pos:o,isAsync:i}}function FieldDecl(e,t,n,r,o=!1){return{kind:"FieldDecl",name:e,type:t,init:n,pos:r,isStatic:o}}function ClassDecl(e,t,n,r){return{kind:"ClassDecl",name:e,methods:t,fields:n,pos:r}}function MethodDecl(e,t,n,r,o,i=null,p=!1){return{kind:"MethodDecl",name:e,params:t,body:n,pos:r,isConstructor:o,returnType:i,isStatic:p}}function NewExpr(e,t,n){return{kind:"NewExpr",callee:e,args:t,pos:n}}function parse(e){let t=0;function n(n=0){return e[t+n]||{type:"eof",value:"",pos:e.length}}function r(e,r){const o=n();if(e&&o.type!==e)throw new Error(`Expected token type ${e}, got ${o.type} at ${o.pos}`);if(r&&o.value!==r)throw new Error(`Expected '${r}', got '${o.value}' at ${o.pos}`);return t++,o}function o(e,r){const o=n();return!(o.type!==e||r&&o.value!==r)&&(t++,!0)}function i(){const e=n();if("identifier"===e.type||"keyword"===e.type)return t++,e;throw new Error(`Expected token type identifier, got ${e.type} at ${e.pos}`)}function p(){const e=n();return"punct"===e.type&&"{"===e.value?function(){const e=r("punct","{"),t=[];for(;"punct"!==n().type||"}"!==n().value;){const e=r("identifier");r("punct",":");const o=p();t.push(TypeProperty(e.value,o,e.pos));const i=n();if("punct"!==i.type||","!==i.value&&";"!==i.value)break;r("punct",i.value)}return r("punct","}"),ObjectType(t,e.pos)}():a()}function a(){const e=n();if("identifier"===e.type){r("identifier");let t=TypeRef(e.value,e.pos);for(;"punct"===n().type&&"["===n().value;){const e=r("punct","[");r("punct","]"),t=ArrayType(t,e.pos)}return t}throw new Error("Expected type name at "+e.pos)}function u(){const e=n();if("keyword"===e.type&&"export"===e.value){const e=r("keyword","export");return ExportDecl(u(),e.pos)}if("keyword"===e.type&&"type"===e.value)return function(){r("keyword","type");const e=r("identifier");r("punct","=");const t=p();return r("punct",";"),TypeDecl(e.value,t,e.pos)}();if("keyword"===e.type&&("function"===e.value||"async"===e.value&&"keyword"===n(1).type&&"function"===n(1).value))return function(){let e=!1;"keyword"===n().type&&"async"===n().value&&(r("keyword","async"),e=!0);r("keyword","function");const t=r("identifier");r("punct","(");const i=[];if(!o("punct",")")){do{const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=a()),i.push(Param(e.value,t,e.pos))}while(o("punct",","));r("punct",")")}let p=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),p=a());const u=c();return FuncDecl(t.value,i,p,u,t.pos,e)}();if("keyword"===e.type&&"let"===e.value)return function(){r("keyword","let");const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=a());let o=null;"punct"===n().type&&"="===n().value&&(r("punct","="),o=s());return r("punct",";"),VarDecl(e.value,t,o,e.pos)}();if("keyword"===e.type&&"const"===e.value)return function(){r("keyword","const");const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=a());if("punct"===n().type&&"="===n().value){r("punct","=");const n=s();return r("punct",";"),ConstDecl(e.value,t,n,e.pos)}throw new Error(`Const '${e.value}' must have an initializer at ${e.pos}`)}();if("keyword"===e.type&&"if"===e.value)return function(){const e=r("keyword","if");r("punct","(");const t=s();r("punct",")");const o=c();let i=null;"keyword"===n().type&&"else"===n().value&&(r("keyword","else"),i=c());return{kind:"IfStmt",cond:t,thenBlock:o,elseBlock:i,pos:e.pos}}();if("keyword"===e.type&&"while"===e.value)return function(){const e=r("keyword","while");r("punct","(");const t=s();r("punct",")");const n=c();return{kind:"WhileStmt",cond:t,body:n,pos:e.pos}}();if("keyword"===e.type&&"for"===e.value)return function(){const e=r("keyword","for");if(r("punct","("),"keyword"===n().type&&("let"===n().value||"const"===n().value)){const t=n().value;r("keyword");const o=r("identifier");let i=null;if("punct"===n().type&&":"===n().value&&(r("punct",":"),i=a()),"identifier"===n().type&&("of"===n().value||"in"===n().value)){const p=n().value;r("identifier");const a=s();r("punct",")");const u=c(),l={declKind:t,name:o.value,typeAnn:i,pos:o.pos};return"of"===p?ForOfStmt(l,a,u,e.pos):ForInStmt(l,a,u,e.pos)}let p=null;"punct"===n().type&&"="===n().value&&(r("punct","="),p=s());const u="let"===t?VarDecl(o.value,i,p,o.pos):ConstDecl(o.value,i,p,o.pos);r("punct",";");const l="punct"===n().type&&";"===n().value?null:s();r("punct",";");const y="punct"===n().type&&")"===n().value?null:s();r("punct",")");return ForStmt(u,l,y,c(),e.pos)}let t=null;if("punct"!==n().type||";"!==n().value){const e=s();t=ExprStmt(e,e.pos)}r("punct",";");const o="punct"===n().type&&";"===n().value?null:s();r("punct",";");const i="punct"===n().type&&")"===n().value?null:s();r("punct",")");const p=c();return ForStmt(t,o,i,p,e.pos)}();if("keyword"===e.type&&"class"===e.value)return function(){const e=r("keyword","class"),t=r("identifier"),i=[],p=[];r("punct","{");for(;"punct"!==n().type||"}"!==n().value;){let e=!1;"keyword"===n().type&&"static"===n().value&&(r("keyword","static"),e=!0);const t=r("identifier");if("punct"===n().type&&"("===n().value){const p=t,u="constructor"===p.value;r("punct","(");const s=[];if("punct"!==n().type||")"!==n().value)do{const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=a()),s.push(Param(e.value,t,e.pos))}while(o("punct",","));r("punct",")");let l=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),l=a());const y=c();i.push(MethodDecl(p.value,s,y,p.pos,u,l,e))}else{const o=t;let i=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),i=a());let u=null;"punct"===n().type&&"="===n().value&&(r("punct","="),u=s()),"punct"===n().type&&";"===n().value&&r("punct",";"),p.push(FieldDecl(o.value,i,u,o.pos,e))}}return r("punct","}"),ClassDecl(t.value,i,p,e.pos)}();if("keyword"===e.type&&"try"===e.value)return function(){const e=r("keyword","try"),t=c();let o=null,i=null;if("keyword"===n().type&&"catch"===n().value){r("keyword","catch"),r("punct","(");const e=r("identifier");r("punct",")");const t=c();o={name:e.value,block:t,pos:e.pos}}"keyword"===n().type&&"finally"===n().value&&(r("keyword","finally"),i=c());return{kind:"TryStmt",tryBlock:t,catchClause:o,finallyBlock:i,pos:e.pos}}();if("keyword"===e.type&&"switch"===e.value)return function(){const e=r("keyword","switch");r("punct","(");const t=s();r("punct",")");const o=[];r("punct","{");for(;"punct"!==n().type||"}"!==n().value;){if("keyword"===n().type&&"case"===n().value){const e=r("keyword","case"),t=s();r("punct",":");const i=[];for(;("keyword"!==n().type||"case"!==n().value&&"default"!==n().value)&&("punct"!==n().type||"}"!==n().value);)i.push(u());o.push(CaseClause(t,i,e.pos));continue}if("keyword"===n().type&&"default"===n().value){const e=r("keyword","default");r("punct",":");const t=[];for(;("keyword"!==n().type||"case"!==n().value&&"default"!==n().value)&&("punct"!==n().type||"}"!==n().value);)t.push(u());o.push(CaseClause(null,t,e.pos));continue}throw new Error("Unexpected token in switch body: "+JSON.stringify(n()))}return r("punct","}"),SwitchStmt(t,o,e.pos)}();if("keyword"===e.type&&"break"===e.value){const e=r("keyword","break");r("punct",";");return BreakStmt(e.pos)}if("keyword"===e.type&&"return"===e.value)return function(){const e=r("keyword","return");if("punct"===n().type&&";"===n().value)return r("punct",";"),ReturnStmt(null,e.pos);const t=s();return r("punct",";"),ReturnStmt(t,e.pos)}();return ExprStmt(s(),r("punct",";").pos)}function c(){const e=r("punct","{"),t=[];for(;"punct"!==n().type||"}"!==n().value;)t.push(u());return r("punct","}"),Block(t,e.pos)}function s(){return y()}function l(){let e=function(){let e=f();for(;;){const r=n();if("punct"!==r.type||"||"!==r.value)break;{t++;const n=f();e=BinaryExpr(r.value,e,n,r.pos)}}return e}();const o=n();if("punct"===o.type&&"?"===o.value){t++;const n=y();r("punct",":");return ConditionalExpr(e,n,y(),o.pos)}return e}function y(){let e=l();const r=n();if("punct"===r.type&&"="===r.value){t++;e=BinaryExpr("=",e,y(),r.pos)}return e}function f(){let e=d();for(;;){const r=n();if("punct"!==r.type||"&&"!==r.value)break;{t++;const n=d();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function d(){let e=m();for(;;){const r=n();if("punct"!==r.type||!["==","!=","===","!=="].includes(r.value))break;{t++;const n=m();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function m(){let e=k();for(;;){const r=n();if("punct"!==r.type||"<"!==r.value&&">"!==r.value&&"<="!==r.value&&">="!==r.value)break;{t++;const n=k();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function k(){let e=v();for(;;){const r=n();if("punct"!==r.type||"+"!==r.value&&"-"!==r.value)break;{t++;const n=v();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function v(){let e=g();for(;;){const r=n();if("punct"!==r.type||"*"!==r.value&&"/"!==r.value)break;{t++;const n=g();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function g(){if("keyword"===n().type&&"new"===n().value){const e=r("keyword","new");let t=null;if("identifier"!==n().type)throw new Error("Expected identifier after 'new' at "+e.pos);{const e=r("identifier");t=Identifier(e.value,e.pos)}r("punct","(");const p=[];if("punct"!==n().type||")"!==n().value)do{p.push(s())}while(o("punct",","));r("punct",")");let a=NewExpr(t,p,e.pos);for(;;){const e=n();if("punct"===e.type&&"."===e.value){r("punct",".");const e=i();a=MemberExpr(a,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),t=s();r("punct","]"),a=IndexExpr(a,t,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),t=[];if("punct"!==n().type||")"!==n().value)do{t.push(s())}while(o("punct",","));r("punct",")"),a=CallExpr(a,t,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),a=UpdateExpr(a,e.value,!1,e.pos)}}return a}let p=function(){const p=n();if("keyword"===p.type&&"await"===p.value){const u=r("keyword","await");return AwaitExpr(s(),u.pos)}if("keyword"===p.type&&"async"===p.value){if("identifier"===n(1).type&&"punct"===n(2).type&&"=>"===n(2).value){const l=r("keyword","async"),y=r("identifier");let f;return r("punct","=>"),f="punct"===n().type&&"{"===n().value?c():s(),ArrowFunction([y.value],f,l.pos,!0)}if("punct"===n(1).type&&"("===n(1).value){function d(t){let n=t+1;const r=e[t+1];if(!r||"punct"!==r.type||"("!==r.value)return!1;if(e[n]&&"punct"===e[n].type&&")"===e[n].value)return e[n+1]&&"punct"===e[n+1].type&&"=>"===e[n+1].value;for(;;){const t=e[n];if(!t)return!1;if("identifier"===t.type){if(n++,e[n]&&"punct"===e[n].type&&","===e[n].value){n++;continue}return!(!e[n]||"punct"!==e[n].type||")"!==e[n].value)&&(e[n+1]&&"punct"===e[n+1].type&&"=>"===e[n+1].value)}return!1}}if(d(t)){const m=r("keyword","async"),k=(r("punct","("),[]);if("punct"!==n().type||")"!==n().value)do{const g=r("identifier");k.push(g.value)}while(o("punct",","));let v;return r("punct",")"),r("punct","=>"),v="punct"===n().type&&"{"===n().value?c():s(),ArrowFunction(k,v,m.pos,!0)}}if("keyword"===p.type&&"async"===p.value&&"keyword"===n(1).type&&"function"===n(1).value){const h=r("keyword","async");r("keyword","function");let b=null;if("identifier"===n().type){b=r("identifier").value}r("punct","(");const T=[];if("punct"!==n().type||")"!==n().value)do{const w=r("identifier");let x=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),x=a()),T.push(Param(w.value,x,w.pos))}while(o("punct",","));r("punct",")");let $=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),$=a());return FunctionExpr(b,T,$,c(),h.pos,!0)}if("keyword"===n(1).type&&"function"===n(1).value){r("keyword","async");const S=r("keyword","function");let E=null;if("identifier"===n().type){E=r("identifier").value}r("punct","(");const C=[];if("punct"!==n().type||")"!==n().value)do{const B=r("identifier");let A=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),A=a()),C.push(Param(B.value,A,B.pos))}while(o("punct",","));r("punct",")");let j=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),j=a());return FunctionExpr(E,C,j,c(),S.pos,!0)}}if("keyword"===p.type&&"function"===p.value){const F=r("keyword","function");let D=null;if("identifier"===n().type){D=r("identifier").value}r("punct","(");const L=[];if(!o("punct",")")){do{const O=r("identifier");let V=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),V=a()),L.push(Param(O.value,V,O.pos))}while(o("punct",","));r("punct",")")}let I=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),I=a());return FunctionExpr(D,L,I,c(),F.pos,!1)}if("bigint"===p.type)return r("bigint"),BigIntLiteral(p.value,p.pos);if("number"===p.type)return r("number"),NumberLiteral(Number(p.value),p.pos);if("string"===p.type)return r("string"),StringLiteral(p.value,p.pos);if("punct"===p.type&&"["===p.value){const M=r("punct","["),P=[];if("punct"!==n().type||"]"!==n().value)do{P.push(s())}while(o("punct",","));return r("punct","]"),ArrayLiteral(P,M.pos)}if("punct"===p.type&&"{"===p.value){const N=r("punct","{"),U=[];if("punct"!==n().type||"}"!==n().value)for(;;){const R="identifier"===n().type||"keyword"===n().type?i():r("identifier");r("punct",":");const q=s();U.push(ObjectLiteralProperty(R.value,q,R.pos));const z=n();if("punct"!==z.type||","!==z.value&&";"!==z.value)break;r("punct",z.value)}return r("punct","}"),ObjectLiteral(U,N.pos)}if("identifier"===p.type&&"punct"===n(1).type&&"=>"===n(1).value){const J=r("identifier");let W;return r("punct","=>"),W="punct"===n().type&&"{"===n().value?c():s(),ArrowFunction([J.value],W,J.pos)}if("identifier"===p.type)return"true"===p.value||"false"===p.value?(r("identifier"),BoolLiteral("true"===p.value,p.pos)):(r("identifier"),Identifier(p.value,p.pos));if("punct"===p.type&&"("===p.value){function K(){let r=t+1;if("punct"===n(1).type&&")"===n(1).value)return"punct"===n(2).type&&"=>"===n(2).value;for(;;){const t=e[r];if(!t)return!1;if("identifier"===t.type){if(r++,e[r]&&"punct"===e[r].type&&","===e[r].value){r++;continue}return!(!e[r]||"punct"!==e[r].type||")"!==e[r].value)&&(e[r+1]&&"punct"===e[r+1].type&&"=>"===e[r+1].value)}return!1}}if(K()){const _=r("punct","("),G=[];if("punct"!==n().type||")"!==n().value)do{const Q=r("identifier");G.push(Q.value)}while(o("punct",","));let H;return r("punct",")"),r("punct","=>"),H="punct"===n().type&&"{"===n().value?c():s(),ArrowFunction(G,H,_.pos)}r("punct","(");const Z=s();return r("punct",")"),Z}throw new Error("Unexpected token in expression: "+JSON.stringify(p))}();for(;;){const e=n();if("punct"===e.type&&"."===e.value){r("punct",".");const e="identifier"===n().type||"keyword"===n().type?i():r("identifier");p=MemberExpr(p,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),t=s();r("punct","]"),p=IndexExpr(p,t,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),t=[];if("punct"!==n().type||")"!==n().value)do{t.push(s())}while(o("punct",","));r("punct",")"),p=CallExpr(p,t,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),p=UpdateExpr(p,e.value,!1,e.pos)}}return p}const h=[];for(;"eof"!==n().type;)h.push(u());return Program(h)}function anyType(){return{kind:"any"}}function primitiveType(e){return"any"===e?anyType():["number","string","boolean","void","bigint","null","undefined","symbol"].includes(e)?{kind:e}:null}function functionType(e,t){return{kind:"function",params:e,returnType:t}}function objectTypeFromAst(e,t,n){const r=new Map;for(const o of e.properties){const e=n(o.type,t);r.set(o.name,e)}return{kind:"object",properties:r}}function typeToString(e){return function e(t,n){if(!t)return"unknown";if("any"===t.kind)return"any";if("function"===t.kind){if(n.has(t))return"(...) => ...";n.add(t);const r=t.params.map(t=>e(t,n)).join(", "),o=e(t.returnType,n);return n.delete(t),`(${r}) => ${o}`}if("object"===t.kind){if(n.has(t))return"{...}";n.add(t);const r=[];for(const[o,i]of t.properties.entries())r.push(`${o}: ${e(i,n)}`);return n.delete(t),`{ ${r.join("; ")} }`}return"array"===t.kind?`${e(t.element,n)}[]`:t.kind}(e,new WeakSet)}class Env{constructor(e=null){this.parent=e,this.types=new Map,this.values=new Map}defineType(e,t){this.types.set(e,t)}lookupType(e){return this.types.has(e)?this.types.get(e):this.parent?this.parent.lookupType(e):null}defineValue(e,t){this.values.set(e,t)}lookupValue(e){return this.values.has(e)?this.values.get(e):this.parent?this.parent.lookupValue(e):null}}function buildPosToLineMap(e){const t=[0];for(let n=0;n<e.length;n++)"\n"===e[n]&&t.push(n+1);return function(e){if("number"!=typeof e||e<0)return null;let n=1;for(let r=0;r<t.length&&t[r]<=e;r++)n=r+1;return n}}function typeCheck(e,t){const n=[],r=new Env;buildPosToLineMap(t);function o(e,t){n.push({msg:e,pos:t&&"number"==typeof t.pos?t.pos:0})}function i(e,t){switch(e.kind){case"TypeRef":{const n=primitiveType(e.name);if(n)return n;const r=t.lookupType(e.name);return r||(o(`Unknown type '${e.name}'`,e),primitiveType("void"))}case"ArrayType":return{kind:"array",element:i(e.element,t)};case"ObjectType":return objectTypeFromAst(e,t,i);default:return o("Unknown type expression kind: "+e.kind,e),primitiveType("void")}}function p(e,t,n){switch(e.kind){case"ExportDecl":p(e.decl,t,n);break;case"TypeDecl":{const n=i(e.type,t);t.defineType(e.name,n);break}case"VarDecl":{let n=e.type?i(e.type,t):null,r=null;e.init&&(r=u(e.init,t)),n&&r&&!c(r,n)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(n)}' (variable '${e.name}')`,e),!n&&r&&(n=r),n||(n=anyType()),t.defineValue(e.name,n);break}case"ConstDecl":{let n=e.type?i(e.type,t):null;if(!e.init){o(`Const '${e.name}' must have an initializer`,e),n=n||anyType(),t.defineValue(e.name,n);break}const r=u(e.init,t);n&&!c(r,n)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(n)}' (const '${e.name}')`,e),n||(n=r||anyType()),t.defineValue(e.name,n);break}case"FuncDecl":{const n=e.params.map(e=>e.type?i(e.type,t):anyType()),r=e.returnType?i(e.returnType,t):anyType(),o=functionType(n,r);t.defineValue(e.name,o);const p=new Env(t);e.params.forEach((e,t)=>{p.defineValue(e.name,n[t])}),a(e.body,p,o);break}case"Block":a(e,t,n);break;case"ReturnStmt":{if(!n){o("Return statement not inside function",e);break}const r=n.returnType;if(null===e.expr)"void"!==r.kind&&o(`Return type mismatch: expected '${typeToString(r)}' but got 'void'`,e);else{const n=u(e.expr,t);c(n,r)||o(`Return type mismatch: expected '${typeToString(r)}' but got '${typeToString(n)}'`,e)}break}case"ExprStmt":u(e.expr,t);break;case"IfStmt":{const r=u(e.cond,t);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in if must be boolean, got '${typeToString(r)}'`,e.cond),p(e.thenBlock,t,n),e.elseBlock&&p(e.elseBlock,t,n);break}case"WhileStmt":{const r=u(e.cond,t);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in while must be boolean, got '${typeToString(r)}'`,e.cond),p(e.body,t,n);break}case"ForStmt":{const r=new Env(t);if(e.init&&p(e.init,r,n),e.test){const t=u(e.test,r);"boolean"!==t.kind&&"any"!==t.kind&&o(`Condition in for must be boolean, got '${typeToString(t)}'`,e.test)}e.update&&u(e.update,r),p(e.body,r,n);break}case"ForOfStmt":{const r=u(e.right,t);let a=anyType();!r||"array"!==r.kind&&"any"!==r.kind?o(`Right-hand side of for-of must be an array, got '${typeToString(r)}'`,e.right):"array"===r.kind&&(a=r.element);const s=new Env(t);let l=a;if(e.left.typeAnn){const n=i(e.left.typeAnn,t);l=n,c(a,n)||o(`for-of variable type '${typeToString(n)}' is not assignable from element type '${typeToString(a)}'`,e)}s.defineValue(e.left.name,l),p(e.body,s,n);break}case"ForInStmt":{u(e.right,t);const r=primitiveType("string")||anyType(),a=new Env(t);let s=r;if(e.left.typeAnn){const n=i(e.left.typeAnn,t);s=n,c(r,n)||o(`for-in variable type '${typeToString(n)}' is not assignable from key type '${typeToString(r)}'`,e)}a.defineValue(e.left.name,s),p(e.body,a,n);break}case"ClassDecl":{const n=new Map,r=new Map,o={kind:"object",properties:r};let p=functionType([],o);const c=new Map;for(const a of e.methods){const e=a.params.map(e=>e.type?i(e.type,t):anyType());if(c.set(a,e),a.isConstructor)p=functionType(e,o);else{const t=functionType(e,anyType());a.isStatic?n.set(a.name,t):r.set(a.name,t)}}if(e.fields&&e.fields.length>0)for(const o of e.fields){let e=null;e=o.type?i(o.type,t):o.init?u(o.init,t):anyType(),o.isStatic?n.set(o.name,e):r.set(o.name,e)}const s={kind:"class",name:e.name,ctor:p,methods:n,instance:o};t.defineValue(e.name,s),t.defineType(e.name,o);for(const o of e.methods)if(!o.isConstructor&&o.returnType){const e=functionType(c.get(o)||[],i(o.returnType,t));o.isStatic?n.set(o.name,e):r.set(o.name,e)}for(const n of e.methods){const e=n.isConstructor?p:r.get(n.name)||functionType([],anyType()),o=new Env(t);n.params.forEach((t,n)=>o.defineValue(t.name,e.params[n]||anyType())),a(n.body,o,e)}break}case"TryStmt":if(a(e.tryBlock,t,n),e.catchClause){const r=new Env(t);r.defineValue(e.catchClause.name,anyType()),a(e.catchClause.block,r,n)}e.finallyBlock&&a(e.finallyBlock,t,n);break;case"SwitchStmt":u(e.discriminant,t);for(const r of e.cases){r.test&&u(r.test,t);for(const e of r.consequent)p(e,t,n)}break;case"BreakStmt":break;default:o("Unknown statement kind: "+e.kind,e)}}function a(e,t,n){const r=new Env(t);for(const t of e.statements)p(t,r,n)}function u(e,t){switch(e.kind){case"NumberLiteral":return primitiveType("number");case"BigIntLiteral":return primitiveType("bigint");case"StringLiteral":return primitiveType("string");case"BoolLiteral":return primitiveType("boolean");case"Identifier":{const n=t.lookupValue(e.name);return n||anyType()}case"AwaitExpr":return u(e.argument,t);case"BinaryExpr":{if("="===e.op){if("Identifier"!==e.left.kind&&"MemberExpr"!==e.left.kind&&"IndexExpr"!==e.left.kind)return o("Invalid assignment target",e.left),u(e.right,t),anyType();const n=u(e.right,t);let r=null;if("Identifier"===e.left.kind)r=t.lookupValue(e.left.name),r||(r=anyType());else if("MemberExpr"===e.left.kind){const n=u(e.left.object,t);!n||"object"!==n.kind&&"array"!==n.kind&&"any"!==n.kind?(o(`Property access '${e.left.property}' on non-object type '${typeToString(n)}'`,e.left),r=anyType()):"object"===n.kind?(r=n.properties.get(e.left.property),r||(o(`Property '${e.left.property}' does not exist on type '${typeToString(n)}'`,e.left),r=anyType())):r="array"===n.kind&&"length"===e.left.property?primitiveType("number"):anyType()}else{const n=u(e.left.object,t);if(!n||"array"!==n.kind&&"any"!==n.kind)o(`Index access on non-array type '${typeToString(n)}'`,e.left),r=anyType();else if("array"===n.kind){const i=u(e.left.index,t);"number"!==i.kind&&"any"!==i.kind&&o(`Array index must be a number, got '${typeToString(i)}'`,e.left.index),r=n.element}else r=anyType()}return c(n,r)||o(`Cannot assign type '${typeToString(n)}' to '${typeToString(r)}'`,e),r}const n=u(e.left,t),r=u(e.right,t);return"any"===n.kind||"any"===r.kind?["==","!=","===","!==","<",">","<=",">="].includes(e.op)||["&&","||"].includes(e.op)?primitiveType("boolean"):(["+","-","*","/"].includes(e.op),anyType()):"+"===e.op?"number"===n.kind&&"number"===r.kind?primitiveType("number"):"string"===n.kind&&"string"===r.kind?primitiveType("string"):(o(`Operator '+' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["-","*","/"].includes(e.op)?"number"===n.kind&&"number"===r.kind?primitiveType("number"):(o(`Operator '${e.op}' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["==","!=","===","!=="].includes(e.op)?n.kind===r.kind&&["number","string","boolean","null","undefined","symbol"].includes(n.kind)?primitiveType("boolean"):(o(`Operator '${e.op}' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["<",">","<=",">="].includes(e.op)?"number"===n.kind&&"number"===r.kind?primitiveType("boolean"):(o(`Operator '${e.op}' requires numeric operands, got '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):"&&"===e.op||"||"===e.op?"boolean"===n.kind&&"boolean"===r.kind?primitiveType("boolean"):(o(`Logical operator '${e.op}' requires boolean operands, got '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):anyType()}case"ConditionalExpr":{const n=u(e.cond,t);"boolean"!==n.kind&&"any"!==n.kind&&o(`Condition in ternary must be boolean, got '${typeToString(n)}'`,e);const r=u(e.thenExpr,t),i=u(e.elseExpr,t);return"any"===r.kind||"any"===i.kind?anyType():JSON.stringify(r)===JSON.stringify(i)?r:c(r,i)?i:c(i,r)?r:(o(`Ternary branches have incompatible types: '${typeToString(r)}' and '${typeToString(i)}'`,e),anyType())}case"CallExpr":{if("MemberExpr"===e.callee.kind&&"map"===e.callee.property){const n=u(e.callee.object,t);if(!n||"array"!==n.kind&&"any"!==n.kind)return o(`Attempting to call 'map' on non-array type '${typeToString(n)}'`,e.callee),anyType();if(1!==e.args.length)return o(`Array.map expects 1 argument but got ${e.args.length}`,e),{kind:"array",element:anyType()};const r=e.args[0];if("ArrowFunction"===r.kind){const e=new Env(t),o="array"===n.kind?n.element:anyType(),i=r.params[0]||null;let p;return i&&e.defineValue(i,o),"Block"===r.body.kind?(a(r.body,e,{kind:"function",params:[o],returnType:anyType()}),p=anyType()):p=u(r.body,e),{kind:"array",element:p}}{const i=u(r,t);if(!i||"function"!==i.kind&&"any"!==i.kind)return o(`map callback is not a function (got '${typeToString(i)}')`,e),{kind:"array",element:anyType()};if("any"===i.kind)return{kind:"array",element:anyType()};const p=i.params[0]||anyType(),a="array"===n.kind?n.element:anyType();return c(a,p)||o(`map callback parameter type mismatch: expected '${typeToString(p)}' but got '${typeToString(a)}'`,e),{kind:"array",element:i.returnType}}}const n=u(e.callee,t);return!n||"function"!==n.kind&&"any"!==n.kind?(o(`Attempting to call non-function of type '${typeToString(n)}'`,e),anyType()):"any"===n.kind?(e.args.forEach(e=>u(e,t)),anyType()):(e.args.length!==n.params.length&&o(`Function expects ${n.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((r,i)=>{const p=u(r,t),a=n.params[i]||anyType();c(p,a)||o(`Argument ${i+1} type mismatch: expected '${typeToString(a)}' but got '${typeToString(p)}'`,e)}),n.returnType)}case"MemberExpr":{const n=u(e.object,t);if(!n)return anyType();if("any"===n.kind)return anyType();if("class"===n.kind){const t=n.methods.get(e.property);return t||(o(`Static property '${e.property}' does not exist on class '${n.name}'`,e),anyType())}if("array"===n.kind)return"length"===e.property?primitiveType("number"):anyType();if("object"===n.kind){const t=n.properties.get(e.property);return t||(o(`Property '${e.property}' does not exist on type '${typeToString(n)}'`,e),anyType())}return anyType()}case"IndexExpr":{const n=u(e.object,t);if(!n)return anyType();if("any"===n.kind)return u(e.index,t),anyType();if("array"!==n.kind)return o(`Index access on non-array type '${typeToString(n)}'`,e),anyType();const r=u(e.index,t);return"number"!==r.kind&&"any"!==r.kind&&o(`Array index must be a number, got '${typeToString(r)}'`,e.index),n.element}case"NewExpr":{const n=u(e.callee,t);if(n&&"class"===n.kind){const r=n.ctor;return e.args.length!==r.params.length&&o(`Constructor expects ${r.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((e,n)=>{const i=u(e,t),p=r.params[n]||anyType();c(i,p)||o(`Constructor argument ${n+1} type mismatch: expected '${typeToString(p)}' but got '${typeToString(i)}'`,e)}),n.instance||r.returnType||anyType()}return n&&"any"!==n.kind?"function"===n.kind?(e.args.forEach((e,n)=>u(e,t)),n.returnType||anyType()):(o("Cannot use 'new' on non-constructor type",e),e.args.forEach(e=>u(e,t)),anyType()):(e.args.forEach(e=>u(e,t)),anyType())}case"ArrowFunction":return functionType(e.params.map(e=>anyType()),anyType());case"ArrayLiteral":{const n=e.elements;if(0===n.length)return{kind:"array",element:anyType()};const r=u(n[0],t);for(let i=1;i<n.length;i++){const p=u(n[i],t);c(p,r)||o(`Array literal elements have incompatible types: '${typeToString(r)}' and '${typeToString(p)}'`,e)}return{kind:"array",element:r}}case"FunctionExpr":{const n=e.params.map(e=>e.type?i(e.type,t):anyType()),r=e.returnType?i(e.returnType,t):anyType(),o=functionType(n,r),p=new Env(t);return e.params.forEach((e,t)=>p.defineValue(e.name,n[t])),a(e.body,p,o),o}case"UpdateExpr":{const n=u(e.argument,t);return"any"===n.kind?anyType():"number"!==n.kind?(o(`Operator '${e.operator}' requires a numeric operand, got '${typeToString(n)}'`,e),anyType()):primitiveType("number")}case"ObjectLiteral":{const n=new Map;for(const r of e.properties){const e=u(r.value,t);n.set(r.name,e)}return{kind:"object",properties:n}}default:return o("Unknown expression kind: "+e.kind,e),anyType()}}function c(e,t,n){const r=n||new WeakMap;if(!e||!t)return!1;if(e===t)return!0;if("any"===e.kind||"any"===t.kind)return!0;if("object"!==e.kind&&"function"!==e.kind&&"array"!==e.kind)return e.kind===t.kind;let o=r.get(e);if(o||(o=new Set,r.set(e,o)),o.has(t))return!0;if(o.add(t),"array"===e.kind&&"array"===t.kind)return c(e.element,t.element,r);if(e.kind===t.kind){if("function"===e.kind){if(e.params.length!==t.params.length)return!1;for(let n=0;n<e.params.length;n++)if(!c(e.params[n],t.params[n],r))return!1;return c(e.returnType,t.returnType,r)}if("object"===e.kind){for(const[n,o]of t.properties.entries()){const t=e.properties.get(n);if(!t||!c(t,o,r))return!1}return!0}return!0}return!1}return["number","string","boolean","void","bigint","null","undefined","symbol","any"].forEach(e=>{r.defineType(e,primitiveType(e))}),function(e,t){for(const n of e.body)p(n,t,null)}(e,r),{errors:n}}function emitJS(e){function t(e){switch(e.kind){case"ExportDecl":{const n=e.decl;return"TypeDecl"===n.kind?"":`export ${t(n)}`}case"TypeDecl":return"";case"VarDecl":return`let ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"ConstDecl":return`const ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"FuncDecl":{const t=e.params.map(e=>e.name).join(", "),r=n(e.body);return`${e.isAsync?"async ":""}function ${e.name}(${t}) ${r}`}case"IfStmt":{const n=e.elseBlock?` else ${t(e.elseBlock)}`:"";return`if (${r(e.cond)}) ${t(e.thenBlock)}${n}`}case"WhileStmt":return`while (${r(e.cond)}) ${t(e.body)}`;case"ForStmt":return`for (${e.init?("VarDecl"===e.init.kind||e.init.kind,t(e.init).replace(/;$/,"")):""}; ${e.test?r(e.test):""}; ${e.update?r(e.update):""}) ${t(e.body)}`;case"ForOfStmt":return`for (${`${e.left.declKind} ${e.left.name}`} of ${r(e.right)}) ${t(e.body)}`;case"ForInStmt":return`for (${`${e.left.declKind} ${e.left.name}`} in ${r(e.right)}) ${t(e.body)}`;case"SwitchStmt":return`switch (${r(e.discriminant)}) {\n${e.cases.map(e=>{if(e.test){const n=e.consequent.map(e=>t(e)).join("\n");return`  case ${r(e.test)}:\n${n.replace(/^/gm,"    ")}`}return`  default:\n${e.consequent.map(e=>t(e)).join("\n").replace(/^/gm,"    ")}`}).join("\n")}\n}`;case"BreakStmt":return"break;";case"ClassDecl":{const o=e.fields||[],i=o.filter(e=>!e.isStatic&&e.init),p=o.filter(e=>e.isStatic&&e.init),a=e.methods.find(e=>e.isConstructor),u=e.methods.filter(e=>!e.isConstructor);let c="";if(a){const e=a.params.map(e=>e.name).join(", "),n=[];for(const e of i)n.push(`this.${e.name} = ${r(e.init)};`);const o=a.body.statements.map(e=>t(e)).filter(Boolean);o.length>0&&n.push(...o);c=`  constructor(${e}) {\n${n.map(e=>`    ${e}`).join("\n")}\n  }`}else if(i.length>0){c=`  constructor() {\n${i.map(e=>`    this.${e.name} = ${r(e.init)};`).join("\n")}\n  }`}const s=[c,u.map(e=>{const t=e.params.map(e=>e.name).join(", ");return`  ${e.isStatic?"static ":""}${e.name}(${t}) ${n(e.body)}`}).join("\n\n")].filter(Boolean).join("\n\n");let l=`class ${e.name} {\n${s.replace(/^/gm,"  ")}\n}`;if(p.length>0){l+="\n"+p.map(t=>`${e.name}.${t.name} = ${r(t.init)};`).join("\n")}return l}case"Block":return n(e);case"TryStmt":return`${`try ${t(e.tryBlock)}`}${e.catchClause?` catch (${e.catchClause.name}) ${t(e.catchClause.block)}`:""}${e.finallyBlock?` finally ${t(e.finallyBlock)}`:""}`;case"ReturnStmt":return null===e.expr?"return;":`return ${r(e.expr)};`;case"ExprStmt":return`${r(e.expr)};`;default:throw new Error("Unknown stmt kind: "+e.kind)}}function n(e){return"{\n"+e.statements.map(e=>t(e)).filter(Boolean).map(e=>"  "+e).join("\n")+"\n}"}function r(e){switch(e.kind){case"NumberLiteral":case"BigIntLiteral":return String(e.value);case"StringLiteral":return`"${e.value}"`;case"BoolLiteral":return e.value?"true":"false";case"Identifier":return e.name;case"BinaryExpr":return`${r(e.left)} ${e.op} ${r(e.right)}`;case"CallExpr":return`${r(e.callee)}(${e.args.map(r).join(", ")})`;case"MemberExpr":return`${r(e.object)}.${e.property}`;case"IndexExpr":return`${r(e.object)}[${r(e.index)}]`;case"FunctionExpr":{const t=e.params.map(e=>e.name).join(", "),r=e.name?` ${e.name}`:"";return`${e.isAsync?"async ":""}function${r}(${t}) ${n(e.body)}`}case"ConditionalExpr":return`${r(e.cond)} ? ${r(e.thenExpr)} : ${r(e.elseExpr)}`;case"ArrowFunction":{const t=1===e.params.length?e.params[0]:`(${e.params.join(", ")})`,o=e.isAsync?"async ":"";return"Block"===e.body.kind?`${o}${t} => ${n(e.body)}`:`${o}${t} => ${r(e.body)}`}case"AwaitExpr":return`await ${r(e.argument)}`;case"ArrayLiteral":return"["+e.elements.map(r).join(", ")+"]";case"UpdateExpr":return e.prefix?`${e.operator}${r(e.argument)}`:`${r(e.argument)}${e.operator}`;case"ObjectLiteral":return`{ ${e.properties.map(e=>`${e.name}: ${r(e.value)}`).join(", ")} }`;case"NewExpr":return`new ${r(e.callee)}(${e.args.map(r).join(", ")})`;default:throw new Error("Unknown expr kind: "+e.kind)}}return e.body.map(t).filter(Boolean).join("\n")}export function transpile(e){const t=[];let n=e.replace(/^\s*import\b[^\n]*?;(?=\s*(?:\r?\n|$))/gim,e=>(t.push(e.trim()),""));const r=/\{\s*(?:[^{}]|\{[^{}]*\})*?\}\s*(?==)/gm;r.test(e)&&e.match(r).forEach(e=>{console.log("Destructuring assignment found:",e)});const o=/\.\.\.\s*\w+/g;o.test(e)&&e.match(o).forEach(e=>{console.log("Spread syntax found:",e)});const i=/\binterface\s+\w+\s*{[^}]*}/gm;i.test(e)&&e.match(i).forEach(e=>{console.log("Interface declaration found:",e)});const p=parse(tokenizeTS(n)),{errors:a}=typeCheck(p,e);if(a.length>0){console.log("Type errors:");const t=e.split(/\r?\n/);for(const n of a){const{msg:r,pos:o}=n;let i=1,p=1;for(let t=0;t<e.length&&t!==o;t++)"\n"===e[t]?(i++,p=1):p++;const a=t[i-1]||"",u=`   ${i} | `;console.log(`\nâ€¢ ${r}`),console.log(u+a),console.log(" ".repeat(u.length)+" ".repeat(p-1)+"^")}throw new Error("Type checking failed")}console.log("No type errors.");const u=emitJS(p);return t.length>0?t.join("\n")+"\n\n"+u:u}