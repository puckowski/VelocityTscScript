"use strict";function tokenize(e){const t=[];let n=0;const r=e=>/[a-zA-Z_]/.test(e),i=e=>/[0-9]/.test(e),o=e=>r(e)||i(e);for(;n<e.length;){let p=e[n];if(" "===p||"\t"===p||"\n"===p||"\r"===p){n++;continue}if("/"===p&&"/"===e[n+1]){for(;n<e.length&&"\n"!==e[n];)n++;continue}if('"'===p||"'"===p){const r=p;let i=n++,o="";for(;n<e.length&&e[n]!==r;)if("\\"===e[n]){if(n+1>=e.length)break;const t=e[n+1];o+="n"===t?"\n":"r"===t?"\r":"t"===t?"\t":"b"===t?"\b":"f"===t?"\f":"v"===t?"\v":"\\"===t?"\\":'"'===t?'"':"'"===t?"'":t,n+=2}else o+=e[n++];if(e[n]!==r)throw new Error("Unterminated string literal at "+i);n++,t.push({type:"string",value:o,pos:i});continue}if(i(p)){let r=n,o="",p=!1;for(;n<e.length&&(i(e[n])||"."===e[n]);){if("."===e[n]){if(p)break;p=!0}o+=e[n++]}p||"n"!==e[n]?t.push({type:"number",value:o,pos:r}):(n++,t.push({type:"bigint",value:o+"n",pos:r}));continue}if(r(p)){let r=n,i="";for(;n<e.length&&o(e[n]);)i+=e[n++];const p=new Set(["type","function","export","let","const","return","if","else","while","for","switch","case","default","break","try","catch","finally","class","extends","new","async","await"]);p.add("static"),t.push({type:p.has(i)?"keyword":"identifier",value:i,pos:r});continue}const a=e.substr(n,3);if(new Set(["===","!=="]).has(a)){t.push({type:"punct",value:a,pos:n}),n+=3;continue}const u=e.substr(n,2);if(new Set(["==","!=","<=",">=","&&","||","=>","++","--"]).has(u)){t.push({type:"punct",value:u,pos:n}),n+=2;continue}if(!["{","}","(",")",";","+","-","*","/","=",",",":",".","<",">","[","]","?","|"].includes(p))throw new Error("Unexpected character: '"+p+"' at position "+n);t.push({type:"punct",value:p,pos:n}),n++}return t}const tokenizeTS=tokenize;function Program(e){return{kind:"Program",body:e}}function TypeDecl(e,t,n){return{kind:"TypeDecl",name:e,type:t,pos:n}}function VarDecl(e,t,n,r){return{kind:"VarDecl",name:e,type:t,init:n,pos:r}}function ConstDecl(e,t,n,r){return{kind:"ConstDecl",name:e,type:t,init:n,pos:r}}function FuncDecl(e,t,n,r,i,o,p=!1){return{kind:"FuncDecl",name:e,typeParams:t,params:n,returnType:r,body:i,pos:o,isAsync:p}}function Param(e,t,n,r=null){return{kind:"Param",name:e,type:t,pos:n,init:r}}function Block(e,t){return{kind:"Block",statements:e,pos:t}}function ReturnStmt(e,t){return{kind:"ReturnStmt",expr:e,pos:t}}function ExprStmt(e,t){return{kind:"ExprStmt",expr:e,pos:t}}function ForStmt(e,t,n,r,i){return{kind:"ForStmt",init:e,test:t,update:n,body:r,pos:i}}function ForOfStmt(e,t,n,r){return{kind:"ForOfStmt",left:e,right:t,body:n,pos:r}}function ForInStmt(e,t,n,r){return{kind:"ForInStmt",left:e,right:t,body:n,pos:r}}function SwitchStmt(e,t,n){return{kind:"SwitchStmt",discriminant:e,cases:t,pos:n}}function CaseClause(e,t,n){return{kind:"CaseClause",test:e,consequent:t,pos:n}}function BreakStmt(e){return{kind:"BreakStmt",pos:e}}function TypeRef(e,t,n){return{kind:"TypeRef",name:e,typeArgs:t,pos:n}}function ObjectType(e,t){return{kind:"ObjectType",properties:e,pos:t}}function TypeProperty(e,t,n){return{kind:"TypeProperty",name:e,type:t,pos:n}}function ArrayType(e,t){return{kind:"ArrayType",element:e,pos:t}}function UnionType(e,t){return{kind:"UnionType",types:e,pos:t}}function ExportDecl(e,t){return{kind:"ExportDecl",decl:e,pos:t}}function Identifier(e,t){return{kind:"Identifier",name:e,pos:t}}function NumberLiteral(e,t){return{kind:"NumberLiteral",value:e,pos:t}}function BigIntLiteral(e,t){return{kind:"BigIntLiteral",value:e,pos:t}}function StringLiteral(e,t){return{kind:"StringLiteral",value:e,pos:t}}function BoolLiteral(e,t){return{kind:"BoolLiteral",value:e,pos:t}}function BinaryExpr(e,t,n,r){return{kind:"BinaryExpr",op:e,left:t,right:n,pos:r}}function ConditionalExpr(e,t,n,r){return{kind:"ConditionalExpr",cond:e,thenExpr:t,elseExpr:n,pos:r}}function CallExpr(e,t,n){return{kind:"CallExpr",callee:e,args:t,pos:n}}function MemberExpr(e,t,n){return{kind:"MemberExpr",object:e,property:t,pos:n}}function ArrayLiteral(e,t){return{kind:"ArrayLiteral",elements:e,pos:t}}function IndexExpr(e,t,n){return{kind:"IndexExpr",object:e,index:t,pos:n}}function ArrowFunction(e,t,n,r=!1){return{kind:"ArrowFunction",params:e,body:t,pos:n,isAsync:r}}function AwaitExpr(e,t){return{kind:"AwaitExpr",argument:e,pos:t}}function UpdateExpr(e,t,n,r){return{kind:"UpdateExpr",argument:e,operator:t,prefix:n,pos:r}}function ObjectLiteral(e,t){return{kind:"ObjectLiteral",properties:e,pos:t}}function ObjectLiteralProperty(e,t,n){return{kind:"ObjectLiteralProperty",name:e,value:t,pos:n}}function FunctionExpr(e,t,n,r,i,o,p=!1){return{kind:"FunctionExpr",name:e,typeParams:t,params:n,returnType:r,body:i,pos:o,isAsync:p}}function FieldDecl(e,t,n,r,i=!1){return{kind:"FieldDecl",name:e,type:t,init:n,pos:r,isStatic:i}}function ClassDecl(e,t,n,r,i=null){return{kind:"ClassDecl",name:e,methods:t,fields:n,pos:r,superClass:i}}function MethodDecl(e,t,n,r,i,o=null,p=!1){return{kind:"MethodDecl",name:e,params:t,body:n,pos:r,isConstructor:i,returnType:o,isStatic:p}}function NewExpr(e,t,n,r){return{kind:"NewExpr",callee:e,args:t,typeArgs:n,pos:r}}function parse(e){let t=0;function n(n=0){return e[t+n]||{type:"eof",value:"",pos:e.length}}function r(e,r){const i=n();if(e&&i.type!==e)throw new Error(`Expected token type ${e}, got ${i.type} at ${i.pos}`);if(r&&i.value!==r)throw new Error(`Expected '${r}', got '${i.value}' at ${i.pos}`);return t++,i}function i(e,r){const i=n();return!(i.type!==e||r&&i.value!==r)&&(t++,!0)}function o(){const e=n();if("identifier"===e.type||"keyword"===e.type)return t++,e;throw new Error(`Expected token type identifier, got ${e.type} at ${e.pos}`)}function p(){const e=n();let t;if(t="punct"===e.type&&"{"===e.value?u():a(),"punct"===n().type&&"|"===n().value){const i=[t];for(;"punct"===n().type&&"|"===n().value;){r("punct","|");const e=n();"punct"===e.type&&"{"===e.value?i.push(u()):i.push(a())}return UnionType(i,e.pos)}return t}function a(){const e=n();if("identifier"===e.type){r("identifier");let t=null;if("punct"===n().type&&"<"===n().value){if(r("punct","<"),t=[],"punct"!==n().type||">"!==n().value)do{t.push(p())}while(i("punct",","));r("punct",">")}let o=TypeRef(e.value,t,e.pos);for(;"punct"===n().type&&"["===n().value;){const e=r("punct","[");r("punct","]"),o=ArrayType(o,e.pos)}return o}throw new Error("Expected type name at "+e.pos)}function u(){const e=r("punct","{"),t=[];for(;"punct"!==n().type||"}"!==n().value;){const e=r("identifier");r("punct",":");const i=p();t.push(TypeProperty(e.value,i,e.pos));const o=n();if("punct"!==o.type||","!==o.value&&";"!==o.value)break;r("punct",o.value)}return r("punct","}"),ObjectType(t,e.pos)}function c(){const e=n();if("keyword"===e.type&&"export"===e.value){const e=r("keyword","export");return ExportDecl(c(),e.pos)}if("keyword"===e.type&&"type"===e.value)return function(){r("keyword","type");const e=r("identifier");r("punct","=");const t=p();return r("punct",";"),TypeDecl(e.value,t,e.pos)}();if("keyword"===e.type&&("function"===e.value||"async"===e.value&&"keyword"===n(1).type&&"function"===n(1).value))return function(){let e=!1;"keyword"===n().type&&"async"===n().value&&(r("keyword","async"),e=!0);r("keyword","function");const t=r("identifier"),o=s();r("punct","(");const a=[];if(!i("punct",")")){do{const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p());let i=null;"punct"===n().type&&"="===n().value&&(r("punct","="),i=y()),a.push(Param(e.value,t,e.pos,i))}while(i("punct",","));r("punct",")")}let u=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),u=p());const c=l();return FuncDecl(t.value,o,a,u,c,t.pos,e)}();if("keyword"===e.type&&"let"===e.value)return function(){r("keyword","let");const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p());let i=null;"punct"===n().type&&"="===n().value&&(r("punct","="),i=y());return r("punct",";"),VarDecl(e.value,t,i,e.pos)}();if("keyword"===e.type&&"const"===e.value)return function(){r("keyword","const");const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p());if("punct"===n().type&&"="===n().value){r("punct","=");const n=y();return r("punct",";"),ConstDecl(e.value,t,n,e.pos)}throw new Error(`Const '${e.value}' must have an initializer at ${e.pos}`)}();if("keyword"===e.type&&"if"===e.value)return function(){const e=r("keyword","if");r("punct","(");const t=y();r("punct",")");const i=l();let o=null;"keyword"===n().type&&"else"===n().value&&(r("keyword","else"),o=l());return{kind:"IfStmt",cond:t,thenBlock:i,elseBlock:o,pos:e.pos}}();if("keyword"===e.type&&"while"===e.value)return function(){const e=r("keyword","while");r("punct","(");const t=y();r("punct",")");const n=l();return{kind:"WhileStmt",cond:t,body:n,pos:e.pos}}();if("keyword"===e.type&&"for"===e.value)return function(){const e=r("keyword","for");if(r("punct","("),"keyword"===n().type&&("let"===n().value||"const"===n().value)){const t=n().value;r("keyword");const i=r("identifier");let o=null;if("punct"===n().type&&":"===n().value&&(r("punct",":"),o=p()),"identifier"===n().type&&("of"===n().value||"in"===n().value)){const p=n().value;r("identifier");const a=y();r("punct",")");const u=l(),c={declKind:t,name:i.value,typeAnn:o,pos:i.pos};return"of"===p?ForOfStmt(c,a,u,e.pos):ForInStmt(c,a,u,e.pos)}let a=null;"punct"===n().type&&"="===n().value&&(r("punct","="),a=y());const u="let"===t?VarDecl(i.value,o,a,i.pos):ConstDecl(i.value,o,a,i.pos);r("punct",";");const c="punct"===n().type&&";"===n().value?null:y();r("punct",";");const s="punct"===n().type&&")"===n().value?null:y();r("punct",")");return ForStmt(u,c,s,l(),e.pos)}let t=null;if("punct"!==n().type||";"!==n().value){const e=y();t=ExprStmt(e,e.pos)}r("punct",";");const i="punct"===n().type&&";"===n().value?null:y();r("punct",";");const o="punct"===n().type&&")"===n().value?null:y();r("punct",")");const a=l();return ForStmt(t,i,o,a,e.pos)}();if("keyword"===e.type&&"class"===e.value)return function(){const e=r("keyword","class"),t=r("identifier"),o=[],a=[];let u=null;if("keyword"===n().type&&"extends"===n().value){r("keyword","extends");u=r("identifier").value}r("punct","{");for(;"punct"!==n().type||"}"!==n().value;){let e=!1;"keyword"===n().type&&"static"===n().value&&(r("keyword","static"),e=!0);const t=r("identifier");if("punct"===n().type&&"("===n().value){const a=t,u="constructor"===a.value;r("punct","(");const c=[];if("punct"!==n().type||")"!==n().value)do{const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p());let i=null;"punct"===n().type&&"="===n().value&&(r("punct","="),i=y()),c.push(Param(e.value,t,e.pos,i))}while(i("punct",","));r("punct",")");let s=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),s=p());const f=l();o.push(MethodDecl(a.value,c,f,a.pos,u,s,e))}else{const i=t;let o=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),o=p());let u=null;"punct"===n().type&&"="===n().value&&(r("punct","="),u=y()),"punct"===n().type&&";"===n().value&&r("punct",";"),a.push(FieldDecl(i.value,o,u,i.pos,e))}}return r("punct","}"),ClassDecl(t.value,o,a,e.pos,u)}();if("keyword"===e.type&&"try"===e.value)return function(){const e=r("keyword","try"),t=l();let i=null,o=null;if("keyword"===n().type&&"catch"===n().value){r("keyword","catch"),r("punct","(");const e=r("identifier");r("punct",")");const t=l();i={name:e.value,block:t,pos:e.pos}}"keyword"===n().type&&"finally"===n().value&&(r("keyword","finally"),o=l());return{kind:"TryStmt",tryBlock:t,catchClause:i,finallyBlock:o,pos:e.pos}}();if("keyword"===e.type&&"switch"===e.value)return function(){const e=r("keyword","switch");r("punct","(");const t=y();r("punct",")");const i=[];r("punct","{");for(;"punct"!==n().type||"}"!==n().value;){if("keyword"===n().type&&"case"===n().value){const e=r("keyword","case"),t=y();r("punct",":");const o=[];for(;("keyword"!==n().type||"case"!==n().value&&"default"!==n().value)&&("punct"!==n().type||"}"!==n().value);)o.push(c());i.push(CaseClause(t,o,e.pos));continue}if("keyword"===n().type&&"default"===n().value){const e=r("keyword","default");r("punct",":");const t=[];for(;("keyword"!==n().type||"case"!==n().value&&"default"!==n().value)&&("punct"!==n().type||"}"!==n().value);)t.push(c());i.push(CaseClause(null,t,e.pos));continue}throw new Error("Unexpected token in switch body: "+JSON.stringify(n()))}return r("punct","}"),SwitchStmt(t,i,e.pos)}();if("keyword"===e.type&&"break"===e.value){const e=r("keyword","break");r("punct",";");return BreakStmt(e.pos)}if("keyword"===e.type&&"return"===e.value)return function(){const e=r("keyword","return");if("punct"===n().type&&";"===n().value)return r("punct",";"),ReturnStmt(null,e.pos);const t=y();return r("punct",";"),ReturnStmt(t,e.pos)}();return ExprStmt(y(),r("punct",";").pos)}function s(){if("punct"!==n().type||"<"!==n().value)return null;r("punct","<");const e=[];if("punct"!==n().type||">"!==n().value)do{const t=r("identifier");e.push(t.value)}while(i("punct",","));return r("punct",">"),e}function l(){const e=r("punct","{"),t=[];for(;"punct"!==n().type||"}"!==n().value;)t.push(c());return r("punct","}"),Block(t,e.pos)}function y(){return d()}function f(){let e=function(){let e=m();for(;;){const r=n();if("punct"!==r.type||"||"!==r.value)break;{t++;const n=m();e=BinaryExpr(r.value,e,n,r.pos)}}return e}();const i=n();if("punct"===i.type&&"?"===i.value){t++;const n=d();r("punct",":");return ConditionalExpr(e,n,d(),i.pos)}return e}function d(){let e=f();const r=n();if("punct"===r.type&&"="===r.value){t++;e=BinaryExpr("=",e,d(),r.pos)}return e}function m(){let e=k();for(;;){const r=n();if("punct"!==r.type||"&&"!==r.value)break;{t++;const n=k();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function k(){let e=v();for(;;){const r=n();if("punct"!==r.type||!["==","!=","===","!=="].includes(r.value))break;{t++;const n=v();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function v(){let e=g();for(;;){const r=n();if("punct"!==r.type||"<"!==r.value&&">"!==r.value&&"<="!==r.value&&">="!==r.value)break;{t++;const n=g();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function g(){let e=h();for(;;){const r=n();if("punct"!==r.type||"+"!==r.value&&"-"!==r.value)break;{t++;const n=h();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function h(){let e=T();for(;;){const r=n();if("punct"!==r.type||"*"!==r.value&&"/"!==r.value)break;{t++;const n=T();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function T(){if("keyword"===n().type&&"new"===n().value){const e=r("keyword","new");let t=null,a=null;if("identifier"!==n().type)throw new Error("Expected identifier after 'new' at "+e.pos);{const e=r("identifier"),o=Identifier(e.value,e.pos);if("punct"===n().type&&"<"===n().value){if(r("punct","<"),a=[],"punct"!==n().type||">"!==n().value)do{a.push(p())}while(i("punct",","));r("punct",">")}t=o}r("punct","(");const u=[];if("punct"!==n().type||")"!==n().value)do{u.push(y())}while(i("punct",","));r("punct",")");let c=NewExpr(t,u,a,e.pos);for(;;){const e=n();if("punct"===e.type&&"."===e.value){r("punct",".");const e=o();c=MemberExpr(c,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),t=y();r("punct","]"),c=IndexExpr(c,t,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),t=[];if("punct"!==n().type||")"!==n().value)do{t.push(y())}while(i("punct",","));r("punct",")"),c=CallExpr(c,t,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),c=UpdateExpr(c,e.value,!1,e.pos)}}return c}let a=function(){const a=n();if("keyword"===a.type&&"await"===a.value){const u=r("keyword","await");return AwaitExpr(y(),u.pos)}if("keyword"===a.type&&"async"===a.value){if("identifier"===n(1).type&&"punct"===n(2).type&&"=>"===n(2).value){const c=r("keyword","async"),f=r("identifier");let d;return r("punct","=>"),d="punct"===n().type&&"{"===n().value?l():y(),ArrowFunction([f.value],d,c.pos,!0)}if("punct"===n(1).type&&"("===n(1).value){function m(t){let n=t+1;const r=e[t+1];if(!r||"punct"!==r.type||"("!==r.value)return!1;if(e[n]&&"punct"===e[n].type&&")"===e[n].value)return e[n+1]&&"punct"===e[n+1].type&&"=>"===e[n+1].value;for(;;){const t=e[n];if(!t)return!1;if("identifier"===t.type){if(n++,e[n]&&"punct"===e[n].type&&","===e[n].value){n++;continue}return!(!e[n]||"punct"!==e[n].type||")"!==e[n].value)&&(e[n+1]&&"punct"===e[n+1].type&&"=>"===e[n+1].value)}return!1}}if(m(t)){const k=r("keyword","async"),v=(r("punct","("),[]);if("punct"!==n().type||")"!==n().value)do{const h=r("identifier");v.push(h.value)}while(i("punct",","));let g;return r("punct",")"),r("punct","=>"),g="punct"===n().type&&"{"===n().value?l():y(),ArrowFunction(v,g,k.pos,!0)}}if("keyword"===a.type&&"async"===a.value&&"keyword"===n(1).type&&"function"===n(1).value){const T=r("keyword","async");r("keyword","function");let b=null;if("identifier"===n().type){b=r("identifier").value}const $=s();r("punct","(");const w=[];if("punct"!==n().type||")"!==n().value)do{const S=r("identifier");let E=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),E=p());let A=null;"punct"===n().type&&"="===n().value&&(r("punct","="),A=y()),w.push(Param(S.value,E,S.pos,A))}while(i("punct",","));r("punct",")");let x=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),x=p());return FunctionExpr(b,$,w,x,l(),T.pos,!0)}if("keyword"===n(1).type&&"function"===n(1).value){r("keyword","async");const C=r("keyword","function");let j=null;if("identifier"===n().type){j=r("identifier").value}const B=s();r("punct","(");const F=[];if("punct"!==n().type||")"!==n().value)do{const P=r("identifier");let L=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),L=p());let I=null;"punct"===n().type&&"="===n().value&&(r("punct","="),I=y()),F.push(Param(P.value,L,P.pos,I))}while(i("punct",","));r("punct",")");let D=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),D=p());return FunctionExpr(j,B,F,D,l(),C.pos,!0)}}if("keyword"===a.type&&"function"===a.value){const M=r("keyword","function");let O=null;if("identifier"===n().type){O=r("identifier").value}const V=s();r("punct","(");const U=[];if(!i("punct",")")){do{const R=r("identifier");let q=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),q=p());let z=null;"punct"===n().type&&"="===n().value&&(r("punct","="),z=y()),U.push(Param(R.value,q,R.pos,z))}while(i("punct",","));r("punct",")")}let N=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),N=p());return FunctionExpr(O,V,U,N,l(),M.pos,!1)}if("bigint"===a.type)return r("bigint"),BigIntLiteral(a.value,a.pos);if("number"===a.type)return r("number"),NumberLiteral(Number(a.value),a.pos);if("string"===a.type)return r("string"),StringLiteral(a.value,a.pos);if("punct"===a.type&&"["===a.value){const J=r("punct","["),W=[];if("punct"!==n().type||"]"!==n().value)do{W.push(y())}while(i("punct",","));return r("punct","]"),ArrayLiteral(W,J.pos)}if("punct"===a.type&&"{"===a.value){const K=r("punct","{"),Z=[];if("punct"!==n().type||"}"!==n().value)for(;;){const _="identifier"===n().type||"keyword"===n().type?o():r("identifier");r("punct",":");const G=y();Z.push(ObjectLiteralProperty(_.value,G,_.pos));const H=n();if("punct"!==H.type||","!==H.value&&";"!==H.value)break;r("punct",H.value)}return r("punct","}"),ObjectLiteral(Z,K.pos)}if("identifier"===a.type&&"punct"===n(1).type&&"=>"===n(1).value){const Q=r("identifier");let X;return r("punct","=>"),X="punct"===n().type&&"{"===n().value?l():y(),ArrowFunction([Q.value],X,Q.pos)}if("identifier"===a.type)return"true"===a.value||"false"===a.value?(r("identifier"),BoolLiteral("true"===a.value,a.pos)):(r("identifier"),Identifier(a.value,a.pos));if("punct"===a.type&&"("===a.value){function Y(){let r=t+1;if("punct"===n(1).type&&")"===n(1).value)return"punct"===n(2).type&&"=>"===n(2).value;for(;;){const t=e[r];if(!t)return!1;if("identifier"===t.type){if(r++,e[r]&&"punct"===e[r].type&&","===e[r].value){r++;continue}return!(!e[r]||"punct"!==e[r].type||")"!==e[r].value)&&(e[r+1]&&"punct"===e[r+1].type&&"=>"===e[r+1].value)}return!1}}if(Y()){const te=r("punct","("),ne=[];if("punct"!==n().type||")"!==n().value)do{const ie=r("identifier");ne.push(ie.value)}while(i("punct",","));let re;return r("punct",")"),r("punct","=>"),re="punct"===n().type&&"{"===n().value?l():y(),ArrowFunction(ne,re,te.pos)}r("punct","(");const ee=y();return r("punct",")"),ee}throw new Error("Unexpected token in expression: "+JSON.stringify(a))}();for(;;){const e=n();if("punct"===e.type&&"."===e.value){r("punct",".");const e="identifier"===n().type||"keyword"===n().type?o():r("identifier");a=MemberExpr(a,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),t=y();r("punct","]"),a=IndexExpr(a,t,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),t=[];if("punct"!==n().type||")"!==n().value)do{t.push(y())}while(i("punct",","));r("punct",")"),a=CallExpr(a,t,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),a=UpdateExpr(a,e.value,!1,e.pos)}}return a}const b=[];for(;"eof"!==n().type;)b.push(c());return Program(b)}function anyType(){return{kind:"any"}}function primitiveType(e){return"any"===e?anyType():"object"===e?{kind:"object",properties:new Map}:["number","string","boolean","void","bigint","null","undefined","symbol"].includes(e)?{kind:e}:null}function functionType(e,t,n=null){return{kind:"function",params:e,returnType:t,typeParams:n}}function objectTypeFromAst(e,t,n){const r=new Map;for(const i of e.properties){const e=n(i.type,t);r.set(i.name,e)}return{kind:"object",properties:r}}function typeToString(e){return function e(t,n){if(!t)return"unknown";if("any"===t.kind)return"any";if("function"===t.kind){if(n.has(t))return"(...) => ...";n.add(t);const r=t.params.map(t=>e(t,n)).join(", "),i=e(t.returnType,n);return n.delete(t),`(${r}) => ${i}`}if("object"===t.kind){if(n.has(t))return"{...}";n.add(t);const r=[];for(const[i,o]of t.properties.entries())r.push(`${i}: ${e(o,n)}`);return n.delete(t),`{ ${r.join("; ")} }`}return"union"===t.kind?t.types.map(t=>e(t,n)).join(" | "):"array"===t.kind?`${e(t.element,n)}[]`:"map"===t.kind?`Map<${e(t.key,n)}, ${e(t.value,n)}>`:"set"===t.kind?`Set<${e(t.element,n)}>`:t.kind}(e,new WeakSet)}class Env{constructor(e=null){this.parent=e,this.types=new Map,this.values=new Map}defineType(e,t){this.types.set(e,t)}lookupType(e){return this.types.has(e)?this.types.get(e):this.parent?this.parent.lookupType(e):null}defineValue(e,t){this.values.set(e,t)}lookupValue(e){return this.values.has(e)?this.values.get(e):this.parent?this.parent.lookupValue(e):null}}function buildPosToLineMap(e){const t=[0];for(let n=0;n<e.length;n++)"\n"===e[n]&&t.push(n+1);return function(e){if("number"!=typeof e||e<0)return null;let n=1;for(let r=0;r<t.length&&t[r]<=e;r++)n=r+1;return n}}function typeCheck(e,t){const n=[],r=new Env;buildPosToLineMap(t);function i(e,t){n.push({msg:e,pos:t&&"number"==typeof t.pos?t.pos:0})}function o(e,t){switch(e.kind){case"TypeRef":{if("Map"===e.name){let n=anyType(),r=anyType();return e.typeArgs&&e.typeArgs.length>=1&&(n=o(e.typeArgs[0],t)),e.typeArgs&&e.typeArgs.length>=2&&(r=o(e.typeArgs[1],t)),{kind:"map",key:n,value:r}}if("Set"===e.name){let n=anyType();return e.typeArgs&&e.typeArgs.length>=1&&(n=o(e.typeArgs[0],t)),{kind:"set",element:n}}const n=primitiveType(e.name);if(n)return n;const r=t.lookupType(e.name);return r||(i(`Unknown type '${e.name}'`,e),primitiveType("void"))}case"UnionType":return{kind:"union",types:e.types.map(e=>o(e,t))};case"ArrayType":return{kind:"array",element:o(e.element,t)};case"ObjectType":return objectTypeFromAst(e,t,o);default:return i("Unknown type expression kind: "+e.kind,e),primitiveType("void")}}function p(e,t,n){if(e&&t)if("typeParam"!==e.kind)if("array"!==e.kind||"array"!==t.kind)if("object"!==e.kind||"object"!==t.kind);else for(const[r,i]of e.properties.entries()){const e=t.properties.get(r);e&&p(i,e,n)}else p(e.element,t.element,n);else n.has(e.name)||n.set(e.name,t)}function a(e,t){if(!e)return e;if("typeParam"===e.kind)return t.has(e.name)?t.get(e.name):anyType();if("array"===e.kind)return{kind:"array",element:a(e.element,t)};if("object"===e.kind){const n=new Map;for(const[r,i]of e.properties.entries())n.set(r,a(i,t));return{kind:"object",properties:n}}if("function"===e.kind){return functionType(e.params.map(e=>a(e,t)),a(e.returnType,t),null)}return e}function u(e,t,n){switch(e.kind){case"ExportDecl":u(e.decl,t,n);break;case"TypeDecl":{const n=o(e.type,t);t.defineType(e.name,n);break}case"VarDecl":{let n=e.type?o(e.type,t):null,r=null;e.init&&(r=s(e.init,t)),n&&r&&!l(r,n)&&i(`Cannot assign type '${typeToString(r)}' to '${typeToString(n)}' (variable '${e.name}')`,e),!n&&r&&(n=r),n||(n=anyType()),t.defineValue(e.name,n);break}case"ConstDecl":{let n=e.type?o(e.type,t):null;if(!e.init){i(`Const '${e.name}' must have an initializer`,e),n=n||anyType(),t.defineValue(e.name,n);break}const r=s(e.init,t);n&&!l(r,n)&&i(`Cannot assign type '${typeToString(r)}' to '${typeToString(n)}' (const '${e.name}')`,e),n||(n=r||anyType()),t.defineValue(e.name,n);break}case"FuncDecl":{const n=new Env(t);e.typeParams&&e.typeParams.forEach(e=>n.defineType(e,{kind:"typeParam",name:e}));const r=e.params.map(e=>e.type?o(e.type,n):e.init?s(e.init,t):anyType()),i=e.returnType?o(e.returnType,n):anyType(),p=functionType(r,i,e.typeParams||null);t.defineValue(e.name,p);const a=new Env(t);if(e.typeParams&&e.typeParams.forEach(e=>a.defineType(e,{kind:"typeParam",name:e})),e.params.forEach((e,t)=>{a.defineValue(e.name,r[t])}),e.typeParams&&e.typeParams.length>0){const t=functionType(r,anyType(),null);c(e.body,a,t)}else c(e.body,a,p);break}case"Block":c(e,t,n);break;case"ReturnStmt":{if(!n){i("Return statement not inside function",e);break}const r=n.returnType;if(null===e.expr)"void"!==r.kind&&i(`Return type mismatch: expected '${typeToString(r)}' but got 'void'`,e);else{const n=s(e.expr,t);l(n,r)||i(`Return type mismatch: expected '${typeToString(r)}' but got '${typeToString(n)}'`,e)}break}case"ExprStmt":s(e.expr,t);break;case"IfStmt":{const r=s(e.cond,t);"boolean"!==r.kind&&"any"!==r.kind&&i(`Condition in if must be boolean, got '${typeToString(r)}'`,e.cond),u(e.thenBlock,t,n),e.elseBlock&&u(e.elseBlock,t,n);break}case"WhileStmt":{const r=s(e.cond,t);"boolean"!==r.kind&&"any"!==r.kind&&i(`Condition in while must be boolean, got '${typeToString(r)}'`,e.cond),u(e.body,t,n);break}case"ForStmt":{const r=new Env(t);if(e.init&&u(e.init,r,n),e.test){const t=s(e.test,r);"boolean"!==t.kind&&"any"!==t.kind&&i(`Condition in for must be boolean, got '${typeToString(t)}'`,e.test)}e.update&&s(e.update,r),u(e.body,r,n);break}case"ForOfStmt":{const r=s(e.right,t);let p=anyType();!r||"array"!==r.kind&&"any"!==r.kind?i(`Right-hand side of for-of must be an array, got '${typeToString(r)}'`,e.right):"array"===r.kind&&(p=r.element);const a=new Env(t);let c=p;if(e.left.typeAnn){const n=o(e.left.typeAnn,t);c=n,l(p,n)||i(`for-of variable type '${typeToString(n)}' is not assignable from element type '${typeToString(p)}'`,e)}a.defineValue(e.left.name,c),u(e.body,a,n);break}case"ForInStmt":{s(e.right,t);const r=primitiveType("string")||anyType(),p=new Env(t);let a=r;if(e.left.typeAnn){const n=o(e.left.typeAnn,t);a=n,l(r,n)||i(`for-in variable type '${typeToString(n)}' is not assignable from key type '${typeToString(r)}'`,e)}p.defineValue(e.left.name,a),u(e.body,p,n);break}case"ClassDecl":{const n=new Map,r=new Map;if(e.superClass){const i=t.lookupValue(e.superClass);if(i&&"class"===i.kind){for(const[e,t]of i.methods.entries())n.set(e,t);if(i.instance&&i.instance.properties)for(const[e,t]of i.instance.properties.entries())r.set(e,t)}}const i={kind:"object",properties:r};let p=functionType([],i);const a=new Map;for(const u of e.methods){const e=u.params.map(e=>e.type?o(e.type,t):e.init?s(e.init,t):anyType());if(a.set(u,e),u.isConstructor)p=functionType(e,i);else{const t=functionType(e,anyType());u.isStatic?n.set(u.name,t):r.set(u.name,t)}}if(e.fields&&e.fields.length>0)for(const i of e.fields){let e=null;e=i.type?o(i.type,t):i.init?s(i.init,t):anyType(),i.isStatic?n.set(i.name,e):r.set(i.name,e)}const u={kind:"class",name:e.name,ctor:p,methods:n,instance:i,super:e.superClass||null};t.defineValue(e.name,u),t.defineType(e.name,i);for(const i of e.methods)if(!i.isConstructor&&i.returnType){const e=functionType(a.get(i)||[],o(i.returnType,t));i.isStatic?n.set(i.name,e):r.set(i.name,e)}for(const n of e.methods){const e=n.isConstructor?p:r.get(n.name)||functionType([],anyType()),i=new Env(t);n.params.forEach((t,n)=>i.defineValue(t.name,e.params[n]||anyType())),c(n.body,i,e)}break}case"TryStmt":if(c(e.tryBlock,t,n),e.catchClause){const r=new Env(t);r.defineValue(e.catchClause.name,anyType()),c(e.catchClause.block,r,n)}e.finallyBlock&&c(e.finallyBlock,t,n);break;case"SwitchStmt":s(e.discriminant,t);for(const r of e.cases){r.test&&s(r.test,t);for(const e of r.consequent)u(e,t,n)}break;case"BreakStmt":break;default:i("Unknown statement kind: "+e.kind,e)}}function c(e,t,n){const r=new Env(t);for(const t of e.statements)u(t,r,n)}function s(e,t){switch(e.kind){case"NumberLiteral":return primitiveType("number");case"BigIntLiteral":return primitiveType("bigint");case"StringLiteral":return primitiveType("string");case"BoolLiteral":return primitiveType("boolean");case"Identifier":{const n=t.lookupValue(e.name);return n||anyType()}case"AwaitExpr":return s(e.argument,t);case"BinaryExpr":{if("="===e.op){if("Identifier"!==e.left.kind&&"MemberExpr"!==e.left.kind&&"IndexExpr"!==e.left.kind)return i("Invalid assignment target",e.left),s(e.right,t),anyType();const n=s(e.right,t);let r=null;if("Identifier"===e.left.kind)r=t.lookupValue(e.left.name),r||(r=anyType());else if("MemberExpr"===e.left.kind){const n=s(e.left.object,t);!n||"object"!==n.kind&&"array"!==n.kind&&"any"!==n.kind?(i(`Property access '${e.left.property}' on non-object type '${typeToString(n)}'`,e.left),r=anyType()):"object"===n.kind?(r=n.properties.get(e.left.property),r||(i(`Property '${e.left.property}' does not exist on type '${typeToString(n)}'`,e.left),r=anyType())):r="array"===n.kind&&"length"===e.left.property?primitiveType("number"):anyType()}else{const n=s(e.left.object,t);if(!n||"array"!==n.kind&&"any"!==n.kind)i(`Index access on non-array type '${typeToString(n)}'`,e.left),r=anyType();else if("array"===n.kind){const o=s(e.left.index,t);"number"!==o.kind&&"any"!==o.kind&&i(`Array index must be a number, got '${typeToString(o)}'`,e.left.index),r=n.element}else r=anyType()}return l(n,r)||i(`Cannot assign type '${typeToString(n)}' to '${typeToString(r)}'`,e),r}const n=s(e.left,t),r=s(e.right,t);return"any"===n.kind||"any"===r.kind?["==","!=","===","!==","<",">","<=",">="].includes(e.op)||["&&","||"].includes(e.op)?primitiveType("boolean"):(["+","-","*","/"].includes(e.op),anyType()):"+"===e.op?"number"===n.kind&&"number"===r.kind?primitiveType("number"):"string"===n.kind&&"string"===r.kind?primitiveType("string"):(i(`Operator '+' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["-","*","/"].includes(e.op)?"number"===n.kind&&"number"===r.kind?primitiveType("number"):(i(`Operator '${e.op}' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["==","!=","===","!=="].includes(e.op)?n.kind===r.kind&&["number","string","boolean","null","undefined","symbol"].includes(n.kind)?primitiveType("boolean"):(i(`Operator '${e.op}' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["<",">","<=",">="].includes(e.op)?"number"===n.kind&&"number"===r.kind?primitiveType("boolean"):(i(`Operator '${e.op}' requires numeric operands, got '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):"&&"===e.op||"||"===e.op?"boolean"===n.kind&&"boolean"===r.kind?primitiveType("boolean"):(i(`Logical operator '${e.op}' requires boolean operands, got '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):anyType()}case"ConditionalExpr":{const n=s(e.cond,t);"boolean"!==n.kind&&"any"!==n.kind&&i(`Condition in ternary must be boolean, got '${typeToString(n)}'`,e);const r=s(e.thenExpr,t),o=s(e.elseExpr,t);return"any"===r.kind||"any"===o.kind?anyType():JSON.stringify(r)===JSON.stringify(o)?r:l(r,o)?o:l(o,r)?r:(i(`Ternary branches have incompatible types: '${typeToString(r)}' and '${typeToString(o)}'`,e),anyType())}case"CallExpr":{if("MemberExpr"===e.callee.kind&&"map"===e.callee.property){const n=s(e.callee.object,t);if(!n||"array"!==n.kind&&"any"!==n.kind)return i(`Attempting to call 'map' on non-array type '${typeToString(n)}'`,e.callee),anyType();if(1!==e.args.length)return i(`Array.map expects 1 argument but got ${e.args.length}`,e),{kind:"array",element:anyType()};const r=e.args[0];if("ArrowFunction"===r.kind){const e=new Env(t),i="array"===n.kind?n.element:anyType(),o=r.params[0]||null;let p;return o&&e.defineValue(o,i),"Block"===r.body.kind?(c(r.body,e,{kind:"function",params:[i],returnType:anyType()}),p=anyType()):p=s(r.body,e),{kind:"array",element:p}}{const o=s(r,t);if(!o||"function"!==o.kind&&"any"!==o.kind)return i(`map callback is not a function (got '${typeToString(o)}')`,e),{kind:"array",element:anyType()};if("any"===o.kind)return{kind:"array",element:anyType()};const p=o.params[0]||anyType(),a="array"===n.kind?n.element:anyType();return l(a,p)||i(`map callback parameter type mismatch: expected '${typeToString(p)}' but got '${typeToString(a)}'`,e),{kind:"array",element:o.returnType}}}const n=s(e.callee,t);if(!n||"function"!==n.kind&&"any"!==n.kind)return i(`Attempting to call non-function of type '${typeToString(n)}'`,e),anyType();if("any"===n.kind)return e.args.forEach(e=>s(e,t)),anyType();if(n.typeParams&&Array.isArray(n.typeParams)&&n.typeParams.length>0){const r=new Map,o=e.args.map(e=>s(e,t));for(let e=0;e<n.params.length&&e<o.length;e++)p(n.params[e],o[e],r);const u=n.params.map(e=>a(e,r)),c=a(n.returnType,r);return e.args.length!==u.length&&i(`Function expects ${u.length} arguments but got ${e.args.length}`,e),e.args.forEach((t,n)=>{const r=o[n],p=u[n]||anyType();l(r,p)||i(`Argument ${n+1} type mismatch: expected '${typeToString(p)}' but got '${typeToString(r)}'`,e)}),c}return e.args.length!==n.params.length&&i(`Function expects ${n.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((r,o)=>{const p=s(r,t),a=n.params[o]||anyType();l(p,a)||i(`Argument ${o+1} type mismatch: expected '${typeToString(a)}' but got '${typeToString(p)}'`,e)}),n.returnType}case"MemberExpr":{const n=s(e.object,t);if(!n)return anyType();if("any"===n.kind)return anyType();if("class"===n.kind){const t=n.methods.get(e.property);return t||(i(`Static property '${e.property}' does not exist on class '${n.name}'`,e),anyType())}if("array"===n.kind)return"length"===e.property?primitiveType("number"):anyType();if("object"===n.kind){const t=n.properties.get(e.property);return t||(i(`Property '${e.property}' does not exist on type '${typeToString(n)}'`,e),anyType())}return anyType()}case"IndexExpr":{const n=s(e.object,t);if(!n)return anyType();if("any"===n.kind)return s(e.index,t),anyType();if("array"!==n.kind)return i(`Index access on non-array type '${typeToString(n)}'`,e),anyType();const r=s(e.index,t);return"number"!==r.kind&&"any"!==r.kind&&i(`Array index must be a number, got '${typeToString(r)}'`,e.index),n.element}case"NewExpr":{if(e.callee&&"Identifier"===e.callee.kind){const n=e.callee.name;if("Map"===n){let n=anyType(),r=anyType();return e.typeArgs&&e.typeArgs.length>=1&&(n=o(e.typeArgs[0],t)),e.typeArgs&&e.typeArgs.length>=2&&(r=o(e.typeArgs[1],t)),e.args.forEach(e=>s(e,t)),{kind:"map",key:n,value:r}}if("Set"===n){let n=anyType();return e.typeArgs&&e.typeArgs.length>=1&&(n=o(e.typeArgs[0],t)),e.args.forEach(e=>s(e,t)),{kind:"set",element:n}}}const n=s(e.callee,t);if(n&&"class"===n.kind){const r=n.ctor;return e.args.length!==r.params.length&&i(`Constructor expects ${r.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((e,n)=>{const o=s(e,t),p=r.params[n]||anyType();l(o,p)||i(`Constructor argument ${n+1} type mismatch: expected '${typeToString(p)}' but got '${typeToString(o)}'`,e)}),n.instance||r.returnType||anyType()}return n&&"any"!==n.kind?"function"===n.kind?(e.args.forEach((e,n)=>s(e,t)),n.returnType||anyType()):(i("Cannot use 'new' on non-constructor type",e),e.args.forEach(e=>s(e,t)),anyType()):(e.args.forEach(e=>s(e,t)),anyType())}case"ArrowFunction":return functionType(e.params.map(e=>anyType()),anyType());case"ArrayLiteral":{const n=e.elements;if(0===n.length)return{kind:"array",element:anyType()};const r=s(n[0],t);for(let o=1;o<n.length;o++){const p=s(n[o],t);l(p,r)||i(`Array literal elements have incompatible types: '${typeToString(r)}' and '${typeToString(p)}'`,e)}return{kind:"array",element:r}}case"FunctionExpr":{const n=e.typeParams||null,r=new Env(t);n&&n.forEach(e=>r.defineType(e,{kind:"typeParam",name:e}));const i=e.params.map(e=>e.type?o(e.type,r):e.init?s(e.init,t):anyType()),p=e.returnType?o(e.returnType,r):anyType(),a=functionType(i,p,n),u=new Env(t);if(n&&n.forEach(e=>u.defineType(e,{kind:"typeParam",name:e})),e.params.forEach((e,t)=>u.defineValue(e.name,i[t])),n&&n.length>0){const t=functionType(i,anyType(),null);c(e.body,u,t)}else c(e.body,u,a);return a}case"UpdateExpr":{const n=s(e.argument,t);return"any"===n.kind?anyType():"number"!==n.kind?(i(`Operator '${e.operator}' requires a numeric operand, got '${typeToString(n)}'`,e),anyType()):primitiveType("number")}case"ObjectLiteral":{const n=new Map;for(const r of e.properties){const e=s(r.value,t);n.set(r.name,e)}return{kind:"object",properties:n}}default:return i("Unknown expression kind: "+e.kind,e),anyType()}}function l(e,t,n){const r=n||new WeakMap;if(!e||!t)return!1;if(e===t)return!0;if("any"===e.kind||"any"===t.kind)return!0;if("union"===t.kind){for(const n of t.types)if(l(e,n,r))return!0;return!1}if("union"===e.kind){for(const n of e.types)if(!l(n,t,r))return!1;return!0}if("object"!==e.kind&&"function"!==e.kind&&"array"!==e.kind)return e.kind===t.kind;let i=r.get(e);if(i||(i=new Set,r.set(e,i)),i.has(t))return!0;if(i.add(t),"array"===e.kind&&"array"===t.kind)return l(e.element,t.element,r);if("map"===e.kind&&"map"===t.kind)return l(e.key,t.key,r)&&l(e.value,t.value,r);if("set"===e.kind&&"set"===t.kind)return l(e.element,t.element,r);if(e.kind===t.kind){if("function"===e.kind){if(e.params.length!==t.params.length)return!1;for(let n=0;n<e.params.length;n++)if(!l(e.params[n],t.params[n],r))return!1;return l(e.returnType,t.returnType,r)}if("object"===e.kind){for(const[n,i]of t.properties.entries()){const t=e.properties.get(n);if(!t||!l(t,i,r))return!1}return!0}return!0}return!1}return["number","string","boolean","void","bigint","null","undefined","symbol","any"].forEach(e=>{r.defineType(e,primitiveType(e))}),function(e,t){for(const n of e.body)u(n,t,null)}(e,r),{errors:n}}function emitJS(e){function t(e){return e?e.init?`${e.name} = ${i(e.init)}`:e.name:""}function n(e){switch(e.kind){case"ExportDecl":{const t=e.decl;return"TypeDecl"===t.kind?"":`export ${n(t)}`}case"TypeDecl":return"";case"VarDecl":return`let ${e.name}`+(e.init?` = ${i(e.init)}`:"")+";";case"ConstDecl":return`const ${e.name}`+(e.init?` = ${i(e.init)}`:"")+";";case"FuncDecl":{const n=e.params.map(t).join(", "),i=r(e.body);return`${e.isAsync?"async ":""}function ${e.name}(${n}) ${i}`}case"IfStmt":{const t=e.elseBlock?` else ${n(e.elseBlock)}`:"";return`if (${i(e.cond)}) ${n(e.thenBlock)}${t}`}case"WhileStmt":return`while (${i(e.cond)}) ${n(e.body)}`;case"ForStmt":return`for (${e.init?("VarDecl"===e.init.kind||e.init.kind,n(e.init).replace(/;$/,"")):""}; ${e.test?i(e.test):""}; ${e.update?i(e.update):""}) ${n(e.body)}`;case"ForOfStmt":return`for (${`${e.left.declKind} ${e.left.name}`} of ${i(e.right)}) ${n(e.body)}`;case"ForInStmt":return`for (${`${e.left.declKind} ${e.left.name}`} in ${i(e.right)}) ${n(e.body)}`;case"SwitchStmt":return`switch (${i(e.discriminant)}) {\n${e.cases.map(e=>{if(e.test){const t=e.consequent.map(e=>n(e)).join("\n");return`  case ${i(e.test)}:\n${t.replace(/^/gm,"    ")}`}return`  default:\n${e.consequent.map(e=>n(e)).join("\n").replace(/^/gm,"    ")}`}).join("\n")}\n}`;case"BreakStmt":return"break;";case"ClassDecl":{const o=e.fields||[],p=o.filter(e=>!e.isStatic&&e.init),a=o.filter(e=>e.isStatic&&e.init),u=e.methods.find(e=>e.isConstructor),c=e.methods.filter(e=>!e.isConstructor);let s="";if(u){const e=u.params.map(t).join(", "),r=[];for(const e of p)r.push(`this.${e.name} = ${i(e.init)};`);const o=u.body.statements.map(e=>n(e)).filter(Boolean);o.length>0&&r.push(...o);s=`  constructor(${e}) {\n${r.map(e=>`    ${e}`).join("\n")}\n  }`}else if(p.length>0){s=`  constructor() {\n${p.map(e=>`    this.${e.name} = ${i(e.init)};`).join("\n")}\n  }`}const l=[s,c.map(e=>{const n=e.params.map(t).join(", ");return`  ${e.isStatic?"static ":""}${e.name}(${n}) ${r(e.body)}`}).join("\n\n")].filter(Boolean).join("\n\n"),y=e.superClass?` extends ${e.superClass}`:"";let f=`class ${e.name}${y} {\n${l.replace(/^/gm,"  ")}\n}`;if(a.length>0){f+="\n"+a.map(t=>`${e.name}.${t.name} = ${i(t.init)};`).join("\n")}return f}case"Block":return r(e);case"TryStmt":return`${`try ${n(e.tryBlock)}`}${e.catchClause?` catch (${e.catchClause.name}) ${n(e.catchClause.block)}`:""}${e.finallyBlock?` finally ${n(e.finallyBlock)}`:""}`;case"ReturnStmt":return null===e.expr?"return;":`return ${i(e.expr)};`;case"ExprStmt":return`${i(e.expr)};`;default:throw new Error("Unknown stmt kind: "+e.kind)}}function r(e){return"{\n"+e.statements.map(e=>n(e)).filter(Boolean).map(e=>"  "+e).join("\n")+"\n}"}function i(e){switch(e.kind){case"NumberLiteral":case"BigIntLiteral":return String(e.value);case"StringLiteral":return`"${e.value}"`;case"BoolLiteral":return e.value?"true":"false";case"Identifier":return e.name;case"BinaryExpr":return`${i(e.left)} ${e.op} ${i(e.right)}`;case"CallExpr":return`${i(e.callee)}(${e.args.map(i).join(", ")})`;case"MemberExpr":return`${i(e.object)}.${e.property}`;case"IndexExpr":return`${i(e.object)}[${i(e.index)}]`;case"FunctionExpr":{const n=e.params.map(t).join(", "),i=e.name?` ${e.name}`:"";return`${e.isAsync?"async ":""}function${i}(${n}) ${r(e.body)}`}case"ConditionalExpr":return`${i(e.cond)} ? ${i(e.thenExpr)} : ${i(e.elseExpr)}`;case"ArrowFunction":{const t=1===e.params.length?e.params[0]:`(${e.params.join(", ")})`,n=e.isAsync?"async ":"";return"Block"===e.body.kind?`${n}${t} => ${r(e.body)}`:`${n}${t} => ${i(e.body)}`}case"AwaitExpr":return`await ${i(e.argument)}`;case"ArrayLiteral":return"["+e.elements.map(i).join(", ")+"]";case"UpdateExpr":return e.prefix?`${e.operator}${i(e.argument)}`:`${i(e.argument)}${e.operator}`;case"ObjectLiteral":return`{ ${e.properties.map(e=>`${e.name}: ${i(e.value)}`).join(", ")} }`;case"NewExpr":return`new ${i(e.callee)}(${e.args.map(i).join(", ")})`;default:throw new Error("Unknown expr kind: "+e.kind)}}return e.body.map(n).filter(Boolean).join("\n")}export function transpile(e){const t=[];let n=e.replace(/^\s*import\b[^\n]*?;(?=\s*(?:\r?\n|$))/gim,e=>(t.push(e.trim()),""));const r=/\{\s*(?:[^{}]|\{[^{}]*\})*?\}\s*(?==)/gm;r.test(e)&&e.match(r).forEach(e=>{console.log("Destructuring assignment found:",e)});const i=/\.\.\.\s*\w+/g;i.test(e)&&e.match(i).forEach(e=>{console.log("Spread syntax found:",e)});const o=/\binterface\s+\w+\s*{[^}]*}/gm;o.test(e)&&e.match(o).forEach(e=>{console.log("Interface declaration found:",e)});const p=parse(tokenizeTS(n)),{errors:a}=typeCheck(p,e);if(a.length>0){console.log("Type errors:");const t=e.split(/\r?\n/);for(const n of a){const{msg:r,pos:i}=n;let o=1,p=1;for(let t=0;t<e.length&&t!==i;t++)"\n"===e[t]?(o++,p=1):p++;const a=t[o-1]||"",u=`   ${o} | `;console.log(`\nâ€¢ ${r}`),console.log(u+a),console.log(" ".repeat(u.length)+" ".repeat(p-1)+"^")}throw new Error("Type checking failed")}console.log("No type errors.");const u=emitJS(p);return t.length>0?t.join("\n")+"\n\n"+u:u}