"use strict";function tokenize(e){const t=[];let n=0;const r=e=>/[a-zA-Z_]/.test(e),o=e=>/[0-9]/.test(e),i=e=>r(e)||o(e);for(;n<e.length;){let a=e[n];if(" "===a||"\t"===a||"\n"===a||"\r"===a){n++;continue}if("/"===a&&"/"===e[n+1]){for(;n<e.length&&"\n"!==e[n];)n++;continue}if('"'===a||"'"===a){const r=a;let o=n++,i="";for(;n<e.length&&e[n]!==r;)if("\\"===e[n]){if(n+1>=e.length)break;const t=e[n+1];i+="n"===t?"\n":"r"===t?"\r":"t"===t?"\t":"b"===t?"\b":"f"===t?"\f":"v"===t?"\v":"\\"===t?"\\":'"'===t?'"':"'"===t?"'":t,n+=2}else i+=e[n++];if(e[n]!==r)throw new Error("Unterminated string literal at "+o);n++,t.push({type:"string",value:i,pos:o});continue}if(o(a)){let r=n,i="",a=!1;for(;n<e.length&&(o(e[n])||"."===e[n]);){if("."===e[n]){if(a)break;a=!0}i+=e[n++]}a||"n"!==e[n]?t.push({type:"number",value:i,pos:r}):(n++,t.push({type:"bigint",value:i+"n",pos:r}));continue}if(r(a)){let r=n,o="";for(;n<e.length&&i(e[n]);)o+=e[n++];const a=new Set(["type","function","export","let","const","return","if","else","while","for","switch","case","default","break","try","catch","finally","class","extends","new","async","await"]);a.add("static"),t.push({type:a.has(o)?"keyword":"identifier",value:o,pos:r});continue}const p=e.substr(n,3);if(new Set(["===","!=="]).has(p)){t.push({type:"punct",value:p,pos:n}),n+=3;continue}const u=e.substr(n,2);if(new Set(["==","!=","<=",">=","&&","||","=>","++","--"]).has(u)){t.push({type:"punct",value:u,pos:n}),n+=2;continue}if(!["{","}","(",")",";","+","-","*","/","=",",",":",".","<",">","[","]","?"].includes(a))throw new Error("Unexpected character: '"+a+"' at position "+n);t.push({type:"punct",value:a,pos:n}),n++}return t}const tokenizeTS=tokenize;function Program(e){return{kind:"Program",body:e}}function TypeDecl(e,t,n){return{kind:"TypeDecl",name:e,type:t,pos:n}}function VarDecl(e,t,n,r){return{kind:"VarDecl",name:e,type:t,init:n,pos:r}}function ConstDecl(e,t,n,r){return{kind:"ConstDecl",name:e,type:t,init:n,pos:r}}function FuncDecl(e,t,n,r,o,i,a=!1){return{kind:"FuncDecl",name:e,typeParams:t,params:n,returnType:r,body:o,pos:i,isAsync:a}}function Param(e,t,n){return{kind:"Param",name:e,type:t,pos:n}}function Block(e,t){return{kind:"Block",statements:e,pos:t}}function ReturnStmt(e,t){return{kind:"ReturnStmt",expr:e,pos:t}}function ExprStmt(e,t){return{kind:"ExprStmt",expr:e,pos:t}}function ForStmt(e,t,n,r,o){return{kind:"ForStmt",init:e,test:t,update:n,body:r,pos:o}}function ForOfStmt(e,t,n,r){return{kind:"ForOfStmt",left:e,right:t,body:n,pos:r}}function ForInStmt(e,t,n,r){return{kind:"ForInStmt",left:e,right:t,body:n,pos:r}}function SwitchStmt(e,t,n){return{kind:"SwitchStmt",discriminant:e,cases:t,pos:n}}function CaseClause(e,t,n){return{kind:"CaseClause",test:e,consequent:t,pos:n}}function BreakStmt(e){return{kind:"BreakStmt",pos:e}}function TypeRef(e,t){return{kind:"TypeRef",name:e,pos:t}}function ObjectType(e,t){return{kind:"ObjectType",properties:e,pos:t}}function TypeProperty(e,t,n){return{kind:"TypeProperty",name:e,type:t,pos:n}}function ArrayType(e,t){return{kind:"ArrayType",element:e,pos:t}}function ExportDecl(e,t){return{kind:"ExportDecl",decl:e,pos:t}}function Identifier(e,t){return{kind:"Identifier",name:e,pos:t}}function NumberLiteral(e,t){return{kind:"NumberLiteral",value:e,pos:t}}function BigIntLiteral(e,t){return{kind:"BigIntLiteral",value:e,pos:t}}function StringLiteral(e,t){return{kind:"StringLiteral",value:e,pos:t}}function BoolLiteral(e,t){return{kind:"BoolLiteral",value:e,pos:t}}function BinaryExpr(e,t,n,r){return{kind:"BinaryExpr",op:e,left:t,right:n,pos:r}}function ConditionalExpr(e,t,n,r){return{kind:"ConditionalExpr",cond:e,thenExpr:t,elseExpr:n,pos:r}}function CallExpr(e,t,n){return{kind:"CallExpr",callee:e,args:t,pos:n}}function MemberExpr(e,t,n){return{kind:"MemberExpr",object:e,property:t,pos:n}}function ArrayLiteral(e,t){return{kind:"ArrayLiteral",elements:e,pos:t}}function IndexExpr(e,t,n){return{kind:"IndexExpr",object:e,index:t,pos:n}}function ArrowFunction(e,t,n,r=!1){return{kind:"ArrowFunction",params:e,body:t,pos:n,isAsync:r}}function AwaitExpr(e,t){return{kind:"AwaitExpr",argument:e,pos:t}}function UpdateExpr(e,t,n,r){return{kind:"UpdateExpr",argument:e,operator:t,prefix:n,pos:r}}function ObjectLiteral(e,t){return{kind:"ObjectLiteral",properties:e,pos:t}}function ObjectLiteralProperty(e,t,n){return{kind:"ObjectLiteralProperty",name:e,value:t,pos:n}}function FunctionExpr(e,t,n,r,o,i,a=!1){return{kind:"FunctionExpr",name:e,typeParams:t,params:n,returnType:r,body:o,pos:i,isAsync:a}}function FieldDecl(e,t,n,r,o=!1){return{kind:"FieldDecl",name:e,type:t,init:n,pos:r,isStatic:o}}function ClassDecl(e,t,n,r,o=null){return{kind:"ClassDecl",name:e,methods:t,fields:n,pos:r,superClass:o}}function MethodDecl(e,t,n,r,o,i=null,a=!1){return{kind:"MethodDecl",name:e,params:t,body:n,pos:r,isConstructor:o,returnType:i,isStatic:a}}function NewExpr(e,t,n){return{kind:"NewExpr",callee:e,args:t,pos:n}}function parse(e){let t=0;function n(n=0){return e[t+n]||{type:"eof",value:"",pos:e.length}}function r(e,r){const o=n();if(e&&o.type!==e)throw new Error(`Expected token type ${e}, got ${o.type} at ${o.pos}`);if(r&&o.value!==r)throw new Error(`Expected '${r}', got '${o.value}' at ${o.pos}`);return t++,o}function o(e,r){const o=n();return!(o.type!==e||r&&o.value!==r)&&(t++,!0)}function i(){const e=n();if("identifier"===e.type||"keyword"===e.type)return t++,e;throw new Error(`Expected token type identifier, got ${e.type} at ${e.pos}`)}function a(){const e=n();return"punct"===e.type&&"{"===e.value?function(){const e=r("punct","{"),t=[];for(;"punct"!==n().type||"}"!==n().value;){const e=r("identifier");r("punct",":");const o=a();t.push(TypeProperty(e.value,o,e.pos));const i=n();if("punct"!==i.type||","!==i.value&&";"!==i.value)break;r("punct",i.value)}return r("punct","}"),ObjectType(t,e.pos)}():p()}function p(){const e=n();if("identifier"===e.type){r("identifier");let t=TypeRef(e.value,e.pos);for(;"punct"===n().type&&"["===n().value;){const e=r("punct","[");r("punct","]"),t=ArrayType(t,e.pos)}return t}throw new Error("Expected type name at "+e.pos)}function u(){const e=n();if("keyword"===e.type&&"export"===e.value){const e=r("keyword","export");return ExportDecl(u(),e.pos)}if("keyword"===e.type&&"type"===e.value)return function(){r("keyword","type");const e=r("identifier");r("punct","=");const t=a();return r("punct",";"),TypeDecl(e.value,t,e.pos)}();if("keyword"===e.type&&("function"===e.value||"async"===e.value&&"keyword"===n(1).type&&"function"===n(1).value))return function(){let e=!1;"keyword"===n().type&&"async"===n().value&&(r("keyword","async"),e=!0);r("keyword","function");const t=r("identifier"),i=c();r("punct","(");const a=[];if(!o("punct",")")){do{const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p()),a.push(Param(e.value,t,e.pos))}while(o("punct",","));r("punct",")")}let u=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),u=p());const l=s();return FuncDecl(t.value,i,a,u,l,t.pos,e)}();if("keyword"===e.type&&"let"===e.value)return function(){r("keyword","let");const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p());let o=null;"punct"===n().type&&"="===n().value&&(r("punct","="),o=l());return r("punct",";"),VarDecl(e.value,t,o,e.pos)}();if("keyword"===e.type&&"const"===e.value)return function(){r("keyword","const");const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p());if("punct"===n().type&&"="===n().value){r("punct","=");const n=l();return r("punct",";"),ConstDecl(e.value,t,n,e.pos)}throw new Error(`Const '${e.value}' must have an initializer at ${e.pos}`)}();if("keyword"===e.type&&"if"===e.value)return function(){const e=r("keyword","if");r("punct","(");const t=l();r("punct",")");const o=s();let i=null;"keyword"===n().type&&"else"===n().value&&(r("keyword","else"),i=s());return{kind:"IfStmt",cond:t,thenBlock:o,elseBlock:i,pos:e.pos}}();if("keyword"===e.type&&"while"===e.value)return function(){const e=r("keyword","while");r("punct","(");const t=l();r("punct",")");const n=s();return{kind:"WhileStmt",cond:t,body:n,pos:e.pos}}();if("keyword"===e.type&&"for"===e.value)return function(){const e=r("keyword","for");if(r("punct","("),"keyword"===n().type&&("let"===n().value||"const"===n().value)){const t=n().value;r("keyword");const o=r("identifier");let i=null;if("punct"===n().type&&":"===n().value&&(r("punct",":"),i=p()),"identifier"===n().type&&("of"===n().value||"in"===n().value)){const a=n().value;r("identifier");const p=l();r("punct",")");const u=s(),c={declKind:t,name:o.value,typeAnn:i,pos:o.pos};return"of"===a?ForOfStmt(c,p,u,e.pos):ForInStmt(c,p,u,e.pos)}let a=null;"punct"===n().type&&"="===n().value&&(r("punct","="),a=l());const u="let"===t?VarDecl(o.value,i,a,o.pos):ConstDecl(o.value,i,a,o.pos);r("punct",";");const c="punct"===n().type&&";"===n().value?null:l();r("punct",";");const y="punct"===n().type&&")"===n().value?null:l();r("punct",")");return ForStmt(u,c,y,s(),e.pos)}let t=null;if("punct"!==n().type||";"!==n().value){const e=l();t=ExprStmt(e,e.pos)}r("punct",";");const o="punct"===n().type&&";"===n().value?null:l();r("punct",";");const i="punct"===n().type&&")"===n().value?null:l();r("punct",")");const a=s();return ForStmt(t,o,i,a,e.pos)}();if("keyword"===e.type&&"class"===e.value)return function(){const e=r("keyword","class"),t=r("identifier"),i=[],a=[];let u=null;if("keyword"===n().type&&"extends"===n().value){r("keyword","extends");u=r("identifier").value}r("punct","{");for(;"punct"!==n().type||"}"!==n().value;){let e=!1;"keyword"===n().type&&"static"===n().value&&(r("keyword","static"),e=!0);const t=r("identifier");if("punct"===n().type&&"("===n().value){const a=t,u="constructor"===a.value;r("punct","(");const c=[];if("punct"!==n().type||")"!==n().value)do{const e=r("identifier");let t=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),t=p()),c.push(Param(e.value,t,e.pos))}while(o("punct",","));r("punct",")");let l=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),l=p());const y=s();i.push(MethodDecl(a.value,c,y,a.pos,u,l,e))}else{const o=t;let i=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),i=p());let u=null;"punct"===n().type&&"="===n().value&&(r("punct","="),u=l()),"punct"===n().type&&";"===n().value&&r("punct",";"),a.push(FieldDecl(o.value,i,u,o.pos,e))}}return r("punct","}"),ClassDecl(t.value,i,a,e.pos,u)}();if("keyword"===e.type&&"try"===e.value)return function(){const e=r("keyword","try"),t=s();let o=null,i=null;if("keyword"===n().type&&"catch"===n().value){r("keyword","catch"),r("punct","(");const e=r("identifier");r("punct",")");const t=s();o={name:e.value,block:t,pos:e.pos}}"keyword"===n().type&&"finally"===n().value&&(r("keyword","finally"),i=s());return{kind:"TryStmt",tryBlock:t,catchClause:o,finallyBlock:i,pos:e.pos}}();if("keyword"===e.type&&"switch"===e.value)return function(){const e=r("keyword","switch");r("punct","(");const t=l();r("punct",")");const o=[];r("punct","{");for(;"punct"!==n().type||"}"!==n().value;){if("keyword"===n().type&&"case"===n().value){const e=r("keyword","case"),t=l();r("punct",":");const i=[];for(;("keyword"!==n().type||"case"!==n().value&&"default"!==n().value)&&("punct"!==n().type||"}"!==n().value);)i.push(u());o.push(CaseClause(t,i,e.pos));continue}if("keyword"===n().type&&"default"===n().value){const e=r("keyword","default");r("punct",":");const t=[];for(;("keyword"!==n().type||"case"!==n().value&&"default"!==n().value)&&("punct"!==n().type||"}"!==n().value);)t.push(u());o.push(CaseClause(null,t,e.pos));continue}throw new Error("Unexpected token in switch body: "+JSON.stringify(n()))}return r("punct","}"),SwitchStmt(t,o,e.pos)}();if("keyword"===e.type&&"break"===e.value){const e=r("keyword","break");r("punct",";");return BreakStmt(e.pos)}if("keyword"===e.type&&"return"===e.value)return function(){const e=r("keyword","return");if("punct"===n().type&&";"===n().value)return r("punct",";"),ReturnStmt(null,e.pos);const t=l();return r("punct",";"),ReturnStmt(t,e.pos)}();return ExprStmt(l(),r("punct",";").pos)}function c(){if("punct"!==n().type||"<"!==n().value)return null;r("punct","<");const e=[];if("punct"!==n().type||">"!==n().value)do{const t=r("identifier");e.push(t.value)}while(o("punct",","));return r("punct",">"),e}function s(){const e=r("punct","{"),t=[];for(;"punct"!==n().type||"}"!==n().value;)t.push(u());return r("punct","}"),Block(t,e.pos)}function l(){return f()}function y(){let e=function(){let e=d();for(;;){const r=n();if("punct"!==r.type||"||"!==r.value)break;{t++;const n=d();e=BinaryExpr(r.value,e,n,r.pos)}}return e}();const o=n();if("punct"===o.type&&"?"===o.value){t++;const n=f();r("punct",":");return ConditionalExpr(e,n,f(),o.pos)}return e}function f(){let e=y();const r=n();if("punct"===r.type&&"="===r.value){t++;e=BinaryExpr("=",e,f(),r.pos)}return e}function d(){let e=m();for(;;){const r=n();if("punct"!==r.type||"&&"!==r.value)break;{t++;const n=m();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function m(){let e=k();for(;;){const r=n();if("punct"!==r.type||!["==","!=","===","!=="].includes(r.value))break;{t++;const n=k();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function k(){let e=v();for(;;){const r=n();if("punct"!==r.type||"<"!==r.value&&">"!==r.value&&"<="!==r.value&&">="!==r.value)break;{t++;const n=v();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function v(){let e=g();for(;;){const r=n();if("punct"!==r.type||"+"!==r.value&&"-"!==r.value)break;{t++;const n=g();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function g(){let e=h();for(;;){const r=n();if("punct"!==r.type||"*"!==r.value&&"/"!==r.value)break;{t++;const n=h();e=BinaryExpr(r.value,e,n,r.pos)}}return e}function h(){if("keyword"===n().type&&"new"===n().value){const e=r("keyword","new");let t=null;if("identifier"!==n().type)throw new Error("Expected identifier after 'new' at "+e.pos);{const e=r("identifier");t=Identifier(e.value,e.pos)}r("punct","(");const a=[];if("punct"!==n().type||")"!==n().value)do{a.push(l())}while(o("punct",","));r("punct",")");let p=NewExpr(t,a,e.pos);for(;;){const e=n();if("punct"===e.type&&"."===e.value){r("punct",".");const e=i();p=MemberExpr(p,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),t=l();r("punct","]"),p=IndexExpr(p,t,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),t=[];if("punct"!==n().type||")"!==n().value)do{t.push(l())}while(o("punct",","));r("punct",")"),p=CallExpr(p,t,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),p=UpdateExpr(p,e.value,!1,e.pos)}}return p}let a=function(){const a=n();if("keyword"===a.type&&"await"===a.value){const u=r("keyword","await");return AwaitExpr(l(),u.pos)}if("keyword"===a.type&&"async"===a.value){if("identifier"===n(1).type&&"punct"===n(2).type&&"=>"===n(2).value){const y=r("keyword","async"),f=r("identifier");let d;return r("punct","=>"),d="punct"===n().type&&"{"===n().value?s():l(),ArrowFunction([f.value],d,y.pos,!0)}if("punct"===n(1).type&&"("===n(1).value){function m(t){let n=t+1;const r=e[t+1];if(!r||"punct"!==r.type||"("!==r.value)return!1;if(e[n]&&"punct"===e[n].type&&")"===e[n].value)return e[n+1]&&"punct"===e[n+1].type&&"=>"===e[n+1].value;for(;;){const t=e[n];if(!t)return!1;if("identifier"===t.type){if(n++,e[n]&&"punct"===e[n].type&&","===e[n].value){n++;continue}return!(!e[n]||"punct"!==e[n].type||")"!==e[n].value)&&(e[n+1]&&"punct"===e[n+1].type&&"=>"===e[n+1].value)}return!1}}if(m(t)){const k=r("keyword","async"),v=(r("punct","("),[]);if("punct"!==n().type||")"!==n().value)do{const h=r("identifier");v.push(h.value)}while(o("punct",","));let g;return r("punct",")"),r("punct","=>"),g="punct"===n().type&&"{"===n().value?s():l(),ArrowFunction(v,g,k.pos,!0)}}if("keyword"===a.type&&"async"===a.value&&"keyword"===n(1).type&&"function"===n(1).value){const T=r("keyword","async");r("keyword","function");let b=null;if("identifier"===n().type){b=r("identifier").value}const $=c();r("punct","(");const w=[];if("punct"!==n().type||")"!==n().value)do{const S=r("identifier");let E=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),E=p()),w.push(Param(S.value,E,S.pos))}while(o("punct",","));r("punct",")");let x=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),x=p());return FunctionExpr(b,$,w,x,s(),T.pos,!0)}if("keyword"===n(1).type&&"function"===n(1).value){r("keyword","async");const C=r("keyword","function");let j=null;if("identifier"===n().type){j=r("identifier").value}const B=c();r("punct","(");const A=[];if("punct"!==n().type||")"!==n().value)do{const D=r("identifier");let P=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),P=p()),A.push(Param(D.value,P,D.pos))}while(o("punct",","));r("punct",")");let F=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),F=p());return FunctionExpr(j,B,A,F,s(),C.pos,!0)}}if("keyword"===a.type&&"function"===a.value){const L=r("keyword","function");let I=null;if("identifier"===n().type){I=r("identifier").value}const O=c();r("punct","(");const V=[];if(!o("punct",")")){do{const N=r("identifier");let U=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),U=p()),V.push(Param(N.value,U,N.pos))}while(o("punct",","));r("punct",")")}let M=null;"punct"===n().type&&":"===n().value&&(r("punct",":"),M=p());return FunctionExpr(I,O,V,M,s(),L.pos,!1)}if("bigint"===a.type)return r("bigint"),BigIntLiteral(a.value,a.pos);if("number"===a.type)return r("number"),NumberLiteral(Number(a.value),a.pos);if("string"===a.type)return r("string"),StringLiteral(a.value,a.pos);if("punct"===a.type&&"["===a.value){const R=r("punct","["),q=[];if("punct"!==n().type||"]"!==n().value)do{q.push(l())}while(o("punct",","));return r("punct","]"),ArrayLiteral(q,R.pos)}if("punct"===a.type&&"{"===a.value){const z=r("punct","{"),J=[];if("punct"!==n().type||"}"!==n().value)for(;;){const W="identifier"===n().type||"keyword"===n().type?i():r("identifier");r("punct",":");const K=l();J.push(ObjectLiteralProperty(W.value,K,W.pos));const Z=n();if("punct"!==Z.type||","!==Z.value&&";"!==Z.value)break;r("punct",Z.value)}return r("punct","}"),ObjectLiteral(J,z.pos)}if("identifier"===a.type&&"punct"===n(1).type&&"=>"===n(1).value){const _=r("identifier");let G;return r("punct","=>"),G="punct"===n().type&&"{"===n().value?s():l(),ArrowFunction([_.value],G,_.pos)}if("identifier"===a.type)return"true"===a.value||"false"===a.value?(r("identifier"),BoolLiteral("true"===a.value,a.pos)):(r("identifier"),Identifier(a.value,a.pos));if("punct"===a.type&&"("===a.value){function H(){let r=t+1;if("punct"===n(1).type&&")"===n(1).value)return"punct"===n(2).type&&"=>"===n(2).value;for(;;){const t=e[r];if(!t)return!1;if("identifier"===t.type){if(r++,e[r]&&"punct"===e[r].type&&","===e[r].value){r++;continue}return!(!e[r]||"punct"!==e[r].type||")"!==e[r].value)&&(e[r+1]&&"punct"===e[r+1].type&&"=>"===e[r+1].value)}return!1}}if(H()){const X=r("punct","("),Y=[];if("punct"!==n().type||")"!==n().value)do{const te=r("identifier");Y.push(te.value)}while(o("punct",","));let ee;return r("punct",")"),r("punct","=>"),ee="punct"===n().type&&"{"===n().value?s():l(),ArrowFunction(Y,ee,X.pos)}r("punct","(");const Q=l();return r("punct",")"),Q}throw new Error("Unexpected token in expression: "+JSON.stringify(a))}();for(;;){const e=n();if("punct"===e.type&&"."===e.value){r("punct",".");const e="identifier"===n().type||"keyword"===n().type?i():r("identifier");a=MemberExpr(a,e.value,e.pos)}else if("punct"===e.type&&"["===e.value){const e=r("punct","["),t=l();r("punct","]"),a=IndexExpr(a,t,e.pos)}else if("punct"===e.type&&"("===e.value){const e=r("punct","("),t=[];if("punct"!==n().type||")"!==n().value)do{t.push(l())}while(o("punct",","));r("punct",")"),a=CallExpr(a,t,e.pos)}else{if("punct"!==e.type||"++"!==e.value&&"--"!==e.value)break;r("punct",e.value),a=UpdateExpr(a,e.value,!1,e.pos)}}return a}const T=[];for(;"eof"!==n().type;)T.push(u());return Program(T)}function anyType(){return{kind:"any"}}function primitiveType(e){return"any"===e?anyType():["number","string","boolean","void","bigint","null","undefined","symbol"].includes(e)?{kind:e}:null}function functionType(e,t,n=null){return{kind:"function",params:e,returnType:t,typeParams:n}}function objectTypeFromAst(e,t,n){const r=new Map;for(const o of e.properties){const e=n(o.type,t);r.set(o.name,e)}return{kind:"object",properties:r}}function typeToString(e){return function e(t,n){if(!t)return"unknown";if("any"===t.kind)return"any";if("function"===t.kind){if(n.has(t))return"(...) => ...";n.add(t);const r=t.params.map(t=>e(t,n)).join(", "),o=e(t.returnType,n);return n.delete(t),`(${r}) => ${o}`}if("object"===t.kind){if(n.has(t))return"{...}";n.add(t);const r=[];for(const[o,i]of t.properties.entries())r.push(`${o}: ${e(i,n)}`);return n.delete(t),`{ ${r.join("; ")} }`}return"array"===t.kind?`${e(t.element,n)}[]`:t.kind}(e,new WeakSet)}class Env{constructor(e=null){this.parent=e,this.types=new Map,this.values=new Map}defineType(e,t){this.types.set(e,t)}lookupType(e){return this.types.has(e)?this.types.get(e):this.parent?this.parent.lookupType(e):null}defineValue(e,t){this.values.set(e,t)}lookupValue(e){return this.values.has(e)?this.values.get(e):this.parent?this.parent.lookupValue(e):null}}function buildPosToLineMap(e){const t=[0];for(let n=0;n<e.length;n++)"\n"===e[n]&&t.push(n+1);return function(e){if("number"!=typeof e||e<0)return null;let n=1;for(let r=0;r<t.length&&t[r]<=e;r++)n=r+1;return n}}function typeCheck(e,t){const n=[],r=new Env;buildPosToLineMap(t);function o(e,t){n.push({msg:e,pos:t&&"number"==typeof t.pos?t.pos:0})}function i(e,t){switch(e.kind){case"TypeRef":{const n=primitiveType(e.name);if(n)return n;const r=t.lookupType(e.name);return r||(o(`Unknown type '${e.name}'`,e),primitiveType("void"))}case"ArrayType":return{kind:"array",element:i(e.element,t)};case"ObjectType":return objectTypeFromAst(e,t,i);default:return o("Unknown type expression kind: "+e.kind,e),primitiveType("void")}}function a(e,t,n){if(e&&t)if("typeParam"!==e.kind)if("array"!==e.kind||"array"!==t.kind)if("object"!==e.kind||"object"!==t.kind);else for(const[r,o]of e.properties.entries()){const e=t.properties.get(r);e&&a(o,e,n)}else a(e.element,t.element,n);else n.has(e.name)||n.set(e.name,t)}function p(e,t){if(!e)return e;if("typeParam"===e.kind)return t.has(e.name)?t.get(e.name):anyType();if("array"===e.kind)return{kind:"array",element:p(e.element,t)};if("object"===e.kind){const n=new Map;for(const[r,o]of e.properties.entries())n.set(r,p(o,t));return{kind:"object",properties:n}}if("function"===e.kind){return functionType(e.params.map(e=>p(e,t)),p(e.returnType,t),null)}return e}function u(e,t,n){switch(e.kind){case"ExportDecl":u(e.decl,t,n);break;case"TypeDecl":{const n=i(e.type,t);t.defineType(e.name,n);break}case"VarDecl":{let n=e.type?i(e.type,t):null,r=null;e.init&&(r=s(e.init,t)),n&&r&&!l(r,n)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(n)}' (variable '${e.name}')`,e),!n&&r&&(n=r),n||(n=anyType()),t.defineValue(e.name,n);break}case"ConstDecl":{let n=e.type?i(e.type,t):null;if(!e.init){o(`Const '${e.name}' must have an initializer`,e),n=n||anyType(),t.defineValue(e.name,n);break}const r=s(e.init,t);n&&!l(r,n)&&o(`Cannot assign type '${typeToString(r)}' to '${typeToString(n)}' (const '${e.name}')`,e),n||(n=r||anyType()),t.defineValue(e.name,n);break}case"FuncDecl":{const n=new Env(t);e.typeParams&&e.typeParams.forEach(e=>n.defineType(e,{kind:"typeParam",name:e}));const r=e.params.map(e=>e.type?i(e.type,n):anyType()),o=e.returnType?i(e.returnType,n):anyType(),a=functionType(r,o,e.typeParams||null);t.defineValue(e.name,a);const p=new Env(t);if(e.typeParams&&e.typeParams.forEach(e=>p.defineType(e,{kind:"typeParam",name:e})),e.params.forEach((e,t)=>{p.defineValue(e.name,r[t])}),e.typeParams&&e.typeParams.length>0){const t=functionType(r,anyType(),null);c(e.body,p,t)}else c(e.body,p,a);break}case"Block":c(e,t,n);break;case"ReturnStmt":{if(!n){o("Return statement not inside function",e);break}const r=n.returnType;if(null===e.expr)"void"!==r.kind&&o(`Return type mismatch: expected '${typeToString(r)}' but got 'void'`,e);else{const n=s(e.expr,t);l(n,r)||o(`Return type mismatch: expected '${typeToString(r)}' but got '${typeToString(n)}'`,e)}break}case"ExprStmt":s(e.expr,t);break;case"IfStmt":{const r=s(e.cond,t);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in if must be boolean, got '${typeToString(r)}'`,e.cond),u(e.thenBlock,t,n),e.elseBlock&&u(e.elseBlock,t,n);break}case"WhileStmt":{const r=s(e.cond,t);"boolean"!==r.kind&&"any"!==r.kind&&o(`Condition in while must be boolean, got '${typeToString(r)}'`,e.cond),u(e.body,t,n);break}case"ForStmt":{const r=new Env(t);if(e.init&&u(e.init,r,n),e.test){const t=s(e.test,r);"boolean"!==t.kind&&"any"!==t.kind&&o(`Condition in for must be boolean, got '${typeToString(t)}'`,e.test)}e.update&&s(e.update,r),u(e.body,r,n);break}case"ForOfStmt":{const r=s(e.right,t);let a=anyType();!r||"array"!==r.kind&&"any"!==r.kind?o(`Right-hand side of for-of must be an array, got '${typeToString(r)}'`,e.right):"array"===r.kind&&(a=r.element);const p=new Env(t);let c=a;if(e.left.typeAnn){const n=i(e.left.typeAnn,t);c=n,l(a,n)||o(`for-of variable type '${typeToString(n)}' is not assignable from element type '${typeToString(a)}'`,e)}p.defineValue(e.left.name,c),u(e.body,p,n);break}case"ForInStmt":{s(e.right,t);const r=primitiveType("string")||anyType(),a=new Env(t);let p=r;if(e.left.typeAnn){const n=i(e.left.typeAnn,t);p=n,l(r,n)||o(`for-in variable type '${typeToString(n)}' is not assignable from key type '${typeToString(r)}'`,e)}a.defineValue(e.left.name,p),u(e.body,a,n);break}case"ClassDecl":{const n=new Map,r=new Map;if(e.superClass){const o=t.lookupValue(e.superClass);if(o&&"class"===o.kind){for(const[e,t]of o.methods.entries())n.set(e,t);if(o.instance&&o.instance.properties)for(const[e,t]of o.instance.properties.entries())r.set(e,t)}}const o={kind:"object",properties:r};let a=functionType([],o);const p=new Map;for(const u of e.methods){const e=u.params.map(e=>e.type?i(e.type,t):anyType());if(p.set(u,e),u.isConstructor)a=functionType(e,o);else{const t=functionType(e,anyType());u.isStatic?n.set(u.name,t):r.set(u.name,t)}}if(e.fields&&e.fields.length>0)for(const o of e.fields){let e=null;e=o.type?i(o.type,t):o.init?s(o.init,t):anyType(),o.isStatic?n.set(o.name,e):r.set(o.name,e)}const u={kind:"class",name:e.name,ctor:a,methods:n,instance:o,super:e.superClass||null};t.defineValue(e.name,u),t.defineType(e.name,o);for(const o of e.methods)if(!o.isConstructor&&o.returnType){const e=functionType(p.get(o)||[],i(o.returnType,t));o.isStatic?n.set(o.name,e):r.set(o.name,e)}for(const n of e.methods){const e=n.isConstructor?a:r.get(n.name)||functionType([],anyType()),o=new Env(t);n.params.forEach((t,n)=>o.defineValue(t.name,e.params[n]||anyType())),c(n.body,o,e)}break}case"TryStmt":if(c(e.tryBlock,t,n),e.catchClause){const r=new Env(t);r.defineValue(e.catchClause.name,anyType()),c(e.catchClause.block,r,n)}e.finallyBlock&&c(e.finallyBlock,t,n);break;case"SwitchStmt":s(e.discriminant,t);for(const r of e.cases){r.test&&s(r.test,t);for(const e of r.consequent)u(e,t,n)}break;case"BreakStmt":break;default:o("Unknown statement kind: "+e.kind,e)}}function c(e,t,n){const r=new Env(t);for(const t of e.statements)u(t,r,n)}function s(e,t){switch(e.kind){case"NumberLiteral":return primitiveType("number");case"BigIntLiteral":return primitiveType("bigint");case"StringLiteral":return primitiveType("string");case"BoolLiteral":return primitiveType("boolean");case"Identifier":{const n=t.lookupValue(e.name);return n||anyType()}case"AwaitExpr":return s(e.argument,t);case"BinaryExpr":{if("="===e.op){if("Identifier"!==e.left.kind&&"MemberExpr"!==e.left.kind&&"IndexExpr"!==e.left.kind)return o("Invalid assignment target",e.left),s(e.right,t),anyType();const n=s(e.right,t);let r=null;if("Identifier"===e.left.kind)r=t.lookupValue(e.left.name),r||(r=anyType());else if("MemberExpr"===e.left.kind){const n=s(e.left.object,t);!n||"object"!==n.kind&&"array"!==n.kind&&"any"!==n.kind?(o(`Property access '${e.left.property}' on non-object type '${typeToString(n)}'`,e.left),r=anyType()):"object"===n.kind?(r=n.properties.get(e.left.property),r||(o(`Property '${e.left.property}' does not exist on type '${typeToString(n)}'`,e.left),r=anyType())):r="array"===n.kind&&"length"===e.left.property?primitiveType("number"):anyType()}else{const n=s(e.left.object,t);if(!n||"array"!==n.kind&&"any"!==n.kind)o(`Index access on non-array type '${typeToString(n)}'`,e.left),r=anyType();else if("array"===n.kind){const i=s(e.left.index,t);"number"!==i.kind&&"any"!==i.kind&&o(`Array index must be a number, got '${typeToString(i)}'`,e.left.index),r=n.element}else r=anyType()}return l(n,r)||o(`Cannot assign type '${typeToString(n)}' to '${typeToString(r)}'`,e),r}const n=s(e.left,t),r=s(e.right,t);return"any"===n.kind||"any"===r.kind?["==","!=","===","!==","<",">","<=",">="].includes(e.op)||["&&","||"].includes(e.op)?primitiveType("boolean"):(["+","-","*","/"].includes(e.op),anyType()):"+"===e.op?"number"===n.kind&&"number"===r.kind?primitiveType("number"):"string"===n.kind&&"string"===r.kind?primitiveType("string"):(o(`Operator '+' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["-","*","/"].includes(e.op)?"number"===n.kind&&"number"===r.kind?primitiveType("number"):(o(`Operator '${e.op}' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["==","!=","===","!=="].includes(e.op)?n.kind===r.kind&&["number","string","boolean","null","undefined","symbol"].includes(n.kind)?primitiveType("boolean"):(o(`Operator '${e.op}' not supported for '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):["<",">","<=",">="].includes(e.op)?"number"===n.kind&&"number"===r.kind?primitiveType("boolean"):(o(`Operator '${e.op}' requires numeric operands, got '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):"&&"===e.op||"||"===e.op?"boolean"===n.kind&&"boolean"===r.kind?primitiveType("boolean"):(o(`Logical operator '${e.op}' requires boolean operands, got '${typeToString(n)}' and '${typeToString(r)}'`,e),anyType()):anyType()}case"ConditionalExpr":{const n=s(e.cond,t);"boolean"!==n.kind&&"any"!==n.kind&&o(`Condition in ternary must be boolean, got '${typeToString(n)}'`,e);const r=s(e.thenExpr,t),i=s(e.elseExpr,t);return"any"===r.kind||"any"===i.kind?anyType():JSON.stringify(r)===JSON.stringify(i)?r:l(r,i)?i:l(i,r)?r:(o(`Ternary branches have incompatible types: '${typeToString(r)}' and '${typeToString(i)}'`,e),anyType())}case"CallExpr":{if("MemberExpr"===e.callee.kind&&"map"===e.callee.property){const n=s(e.callee.object,t);if(!n||"array"!==n.kind&&"any"!==n.kind)return o(`Attempting to call 'map' on non-array type '${typeToString(n)}'`,e.callee),anyType();if(1!==e.args.length)return o(`Array.map expects 1 argument but got ${e.args.length}`,e),{kind:"array",element:anyType()};const r=e.args[0];if("ArrowFunction"===r.kind){const e=new Env(t),o="array"===n.kind?n.element:anyType(),i=r.params[0]||null;let a;return i&&e.defineValue(i,o),"Block"===r.body.kind?(c(r.body,e,{kind:"function",params:[o],returnType:anyType()}),a=anyType()):a=s(r.body,e),{kind:"array",element:a}}{const i=s(r,t);if(!i||"function"!==i.kind&&"any"!==i.kind)return o(`map callback is not a function (got '${typeToString(i)}')`,e),{kind:"array",element:anyType()};if("any"===i.kind)return{kind:"array",element:anyType()};const a=i.params[0]||anyType(),p="array"===n.kind?n.element:anyType();return l(p,a)||o(`map callback parameter type mismatch: expected '${typeToString(a)}' but got '${typeToString(p)}'`,e),{kind:"array",element:i.returnType}}}const n=s(e.callee,t);if(!n||"function"!==n.kind&&"any"!==n.kind)return o(`Attempting to call non-function of type '${typeToString(n)}'`,e),anyType();if("any"===n.kind)return e.args.forEach(e=>s(e,t)),anyType();if(n.typeParams&&Array.isArray(n.typeParams)&&n.typeParams.length>0){const r=new Map,i=e.args.map(e=>s(e,t));for(let e=0;e<n.params.length&&e<i.length;e++)a(n.params[e],i[e],r);const u=n.params.map(e=>p(e,r)),c=p(n.returnType,r);return e.args.length!==u.length&&o(`Function expects ${u.length} arguments but got ${e.args.length}`,e),e.args.forEach((t,n)=>{const r=i[n],a=u[n]||anyType();l(r,a)||o(`Argument ${n+1} type mismatch: expected '${typeToString(a)}' but got '${typeToString(r)}'`,e)}),c}return e.args.length!==n.params.length&&o(`Function expects ${n.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((r,i)=>{const a=s(r,t),p=n.params[i]||anyType();l(a,p)||o(`Argument ${i+1} type mismatch: expected '${typeToString(p)}' but got '${typeToString(a)}'`,e)}),n.returnType}case"MemberExpr":{const n=s(e.object,t);if(!n)return anyType();if("any"===n.kind)return anyType();if("class"===n.kind){const t=n.methods.get(e.property);return t||(o(`Static property '${e.property}' does not exist on class '${n.name}'`,e),anyType())}if("array"===n.kind)return"length"===e.property?primitiveType("number"):anyType();if("object"===n.kind){const t=n.properties.get(e.property);return t||(o(`Property '${e.property}' does not exist on type '${typeToString(n)}'`,e),anyType())}return anyType()}case"IndexExpr":{const n=s(e.object,t);if(!n)return anyType();if("any"===n.kind)return s(e.index,t),anyType();if("array"!==n.kind)return o(`Index access on non-array type '${typeToString(n)}'`,e),anyType();const r=s(e.index,t);return"number"!==r.kind&&"any"!==r.kind&&o(`Array index must be a number, got '${typeToString(r)}'`,e.index),n.element}case"NewExpr":{const n=s(e.callee,t);if(n&&"class"===n.kind){const r=n.ctor;return e.args.length!==r.params.length&&o(`Constructor expects ${r.params.length} arguments but got ${e.args.length}`,e),e.args.forEach((e,n)=>{const i=s(e,t),a=r.params[n]||anyType();l(i,a)||o(`Constructor argument ${n+1} type mismatch: expected '${typeToString(a)}' but got '${typeToString(i)}'`,e)}),n.instance||r.returnType||anyType()}return n&&"any"!==n.kind?"function"===n.kind?(e.args.forEach((e,n)=>s(e,t)),n.returnType||anyType()):(o("Cannot use 'new' on non-constructor type",e),e.args.forEach(e=>s(e,t)),anyType()):(e.args.forEach(e=>s(e,t)),anyType())}case"ArrowFunction":return functionType(e.params.map(e=>anyType()),anyType());case"ArrayLiteral":{const n=e.elements;if(0===n.length)return{kind:"array",element:anyType()};const r=s(n[0],t);for(let i=1;i<n.length;i++){const a=s(n[i],t);l(a,r)||o(`Array literal elements have incompatible types: '${typeToString(r)}' and '${typeToString(a)}'`,e)}return{kind:"array",element:r}}case"FunctionExpr":{const n=e.typeParams||null,r=new Env(t);n&&n.forEach(e=>r.defineType(e,{kind:"typeParam",name:e}));const o=e.params.map(e=>e.type?i(e.type,r):anyType()),a=e.returnType?i(e.returnType,r):anyType(),p=functionType(o,a,n),u=new Env(t);if(n&&n.forEach(e=>u.defineType(e,{kind:"typeParam",name:e})),e.params.forEach((e,t)=>u.defineValue(e.name,o[t])),n&&n.length>0){const t=functionType(o,anyType(),null);c(e.body,u,t)}else c(e.body,u,p);return p}case"UpdateExpr":{const n=s(e.argument,t);return"any"===n.kind?anyType():"number"!==n.kind?(o(`Operator '${e.operator}' requires a numeric operand, got '${typeToString(n)}'`,e),anyType()):primitiveType("number")}case"ObjectLiteral":{const n=new Map;for(const r of e.properties){const e=s(r.value,t);n.set(r.name,e)}return{kind:"object",properties:n}}default:return o("Unknown expression kind: "+e.kind,e),anyType()}}function l(e,t,n){const r=n||new WeakMap;if(!e||!t)return!1;if(e===t)return!0;if("any"===e.kind||"any"===t.kind)return!0;if("object"!==e.kind&&"function"!==e.kind&&"array"!==e.kind)return e.kind===t.kind;let o=r.get(e);if(o||(o=new Set,r.set(e,o)),o.has(t))return!0;if(o.add(t),"array"===e.kind&&"array"===t.kind)return l(e.element,t.element,r);if(e.kind===t.kind){if("function"===e.kind){if(e.params.length!==t.params.length)return!1;for(let n=0;n<e.params.length;n++)if(!l(e.params[n],t.params[n],r))return!1;return l(e.returnType,t.returnType,r)}if("object"===e.kind){for(const[n,o]of t.properties.entries()){const t=e.properties.get(n);if(!t||!l(t,o,r))return!1}return!0}return!0}return!1}return["number","string","boolean","void","bigint","null","undefined","symbol","any"].forEach(e=>{r.defineType(e,primitiveType(e))}),function(e,t){for(const n of e.body)u(n,t,null)}(e,r),{errors:n}}function emitJS(e){function t(e){switch(e.kind){case"ExportDecl":{const n=e.decl;return"TypeDecl"===n.kind?"":`export ${t(n)}`}case"TypeDecl":return"";case"VarDecl":return`let ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"ConstDecl":return`const ${e.name}`+(e.init?` = ${r(e.init)}`:"")+";";case"FuncDecl":{const t=e.params.map(e=>e.name).join(", "),r=n(e.body);return`${e.isAsync?"async ":""}function ${e.name}(${t}) ${r}`}case"IfStmt":{const n=e.elseBlock?` else ${t(e.elseBlock)}`:"";return`if (${r(e.cond)}) ${t(e.thenBlock)}${n}`}case"WhileStmt":return`while (${r(e.cond)}) ${t(e.body)}`;case"ForStmt":return`for (${e.init?("VarDecl"===e.init.kind||e.init.kind,t(e.init).replace(/;$/,"")):""}; ${e.test?r(e.test):""}; ${e.update?r(e.update):""}) ${t(e.body)}`;case"ForOfStmt":return`for (${`${e.left.declKind} ${e.left.name}`} of ${r(e.right)}) ${t(e.body)}`;case"ForInStmt":return`for (${`${e.left.declKind} ${e.left.name}`} in ${r(e.right)}) ${t(e.body)}`;case"SwitchStmt":return`switch (${r(e.discriminant)}) {\n${e.cases.map(e=>{if(e.test){const n=e.consequent.map(e=>t(e)).join("\n");return`  case ${r(e.test)}:\n${n.replace(/^/gm,"    ")}`}return`  default:\n${e.consequent.map(e=>t(e)).join("\n").replace(/^/gm,"    ")}`}).join("\n")}\n}`;case"BreakStmt":return"break;";case"ClassDecl":{const o=e.fields||[],i=o.filter(e=>!e.isStatic&&e.init),a=o.filter(e=>e.isStatic&&e.init),p=e.methods.find(e=>e.isConstructor),u=e.methods.filter(e=>!e.isConstructor);let c="";if(p){const e=p.params.map(e=>e.name).join(", "),n=[];for(const e of i)n.push(`this.${e.name} = ${r(e.init)};`);const o=p.body.statements.map(e=>t(e)).filter(Boolean);o.length>0&&n.push(...o);c=`  constructor(${e}) {\n${n.map(e=>`    ${e}`).join("\n")}\n  }`}else if(i.length>0){c=`  constructor() {\n${i.map(e=>`    this.${e.name} = ${r(e.init)};`).join("\n")}\n  }`}const s=[c,u.map(e=>{const t=e.params.map(e=>e.name).join(", ");return`  ${e.isStatic?"static ":""}${e.name}(${t}) ${n(e.body)}`}).join("\n\n")].filter(Boolean).join("\n\n"),l=e.superClass?` extends ${e.superClass}`:"";let y=`class ${e.name}${l} {\n${s.replace(/^/gm,"  ")}\n}`;if(a.length>0){y+="\n"+a.map(t=>`${e.name}.${t.name} = ${r(t.init)};`).join("\n")}return y}case"Block":return n(e);case"TryStmt":return`${`try ${t(e.tryBlock)}`}${e.catchClause?` catch (${e.catchClause.name}) ${t(e.catchClause.block)}`:""}${e.finallyBlock?` finally ${t(e.finallyBlock)}`:""}`;case"ReturnStmt":return null===e.expr?"return;":`return ${r(e.expr)};`;case"ExprStmt":return`${r(e.expr)};`;default:throw new Error("Unknown stmt kind: "+e.kind)}}function n(e){return"{\n"+e.statements.map(e=>t(e)).filter(Boolean).map(e=>"  "+e).join("\n")+"\n}"}function r(e){switch(e.kind){case"NumberLiteral":case"BigIntLiteral":return String(e.value);case"StringLiteral":return`"${e.value}"`;case"BoolLiteral":return e.value?"true":"false";case"Identifier":return e.name;case"BinaryExpr":return`${r(e.left)} ${e.op} ${r(e.right)}`;case"CallExpr":return`${r(e.callee)}(${e.args.map(r).join(", ")})`;case"MemberExpr":return`${r(e.object)}.${e.property}`;case"IndexExpr":return`${r(e.object)}[${r(e.index)}]`;case"FunctionExpr":{const t=e.params.map(e=>e.name).join(", "),r=e.name?` ${e.name}`:"";return`${e.isAsync?"async ":""}function${r}(${t}) ${n(e.body)}`}case"ConditionalExpr":return`${r(e.cond)} ? ${r(e.thenExpr)} : ${r(e.elseExpr)}`;case"ArrowFunction":{const t=1===e.params.length?e.params[0]:`(${e.params.join(", ")})`,o=e.isAsync?"async ":"";return"Block"===e.body.kind?`${o}${t} => ${n(e.body)}`:`${o}${t} => ${r(e.body)}`}case"AwaitExpr":return`await ${r(e.argument)}`;case"ArrayLiteral":return"["+e.elements.map(r).join(", ")+"]";case"UpdateExpr":return e.prefix?`${e.operator}${r(e.argument)}`:`${r(e.argument)}${e.operator}`;case"ObjectLiteral":return`{ ${e.properties.map(e=>`${e.name}: ${r(e.value)}`).join(", ")} }`;case"NewExpr":return`new ${r(e.callee)}(${e.args.map(r).join(", ")})`;default:throw new Error("Unknown expr kind: "+e.kind)}}return e.body.map(t).filter(Boolean).join("\n")}export function transpile(e){const t=[];let n=e.replace(/^\s*import\b[^\n]*?;(?=\s*(?:\r?\n|$))/gim,e=>(t.push(e.trim()),""));const r=/\{\s*(?:[^{}]|\{[^{}]*\})*?\}\s*(?==)/gm;r.test(e)&&e.match(r).forEach(e=>{console.log("Destructuring assignment found:",e)});const o=/\.\.\.\s*\w+/g;o.test(e)&&e.match(o).forEach(e=>{console.log("Spread syntax found:",e)});const i=/\binterface\s+\w+\s*{[^}]*}/gm;i.test(e)&&e.match(i).forEach(e=>{console.log("Interface declaration found:",e)});const a=parse(tokenizeTS(n)),{errors:p}=typeCheck(a,e);if(p.length>0){console.log("Type errors:");const t=e.split(/\r?\n/);for(const n of p){const{msg:r,pos:o}=n;let i=1,a=1;for(let t=0;t<e.length&&t!==o;t++)"\n"===e[t]?(i++,a=1):a++;const p=t[i-1]||"",u=`   ${i} | `;console.log(`\nâ€¢ ${r}`),console.log(u+p),console.log(" ".repeat(u.length)+" ".repeat(a-1)+"^")}throw new Error("Type checking failed")}console.log("No type errors.");const u=emitJS(a);return t.length>0?t.join("\n")+"\n\n"+u:u}